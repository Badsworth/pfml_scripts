import copy
from datetime import date, datetime

import factory.random
from dateutil.relativedelta import relativedelta
from freezegun import freeze_time
from sqlalchemy import inspect

import massgov.pfml.fineos.mock_client
import massgov.pfml.fineos.models
import tests.api
from massgov.pfml.api.models.applications.common import DurationBasis, FrequencyIntervalBasis
from massgov.pfml.api.models.applications.responses import ApplicationStatus
from massgov.pfml.api.util.response import IssueRule, IssueType
from massgov.pfml.db.models.applications import (
    Application,
    ApplicationPaymentPreference,
    ContinuousLeavePeriod,
    DocumentType,
    EmploymentStatus,
    FINEOSWebIdExt,
    LeaveReason,
    LeaveReasonQualifier,
    RelationshipQualifier,
    RelationshipToCaregiver,
    WorkPattern,
    WorkPatternDay,
)
from massgov.pfml.db.models.employees import Address, TaxIdentifier
from massgov.pfml.db.models.factories import (
    AddressFactory,
    ApplicationFactory,
    ContinuousLeavePeriodFactory,
    DocumentFactory,
    IntermittentLeavePeriodFactory,
    ReducedScheduleLeavePeriodFactory,
    UserFactory,
    WorkPatternFixedFactory,
)


def sqlalchemy_object_as_dict(obj):
    return {c.key: getattr(obj, c.key) for c in inspect(obj).mapper.column_attrs}


# The UUID used in this test was generated online. Hopefully it will never match any of
# the IDs generated by our seed data generator. If it does the test will fail.
def test_applications_get_invalid(client, user, auth_token):
    response = client.get(
        "/v1/applications/{}".format("b26aa854-dd50-4aed-906b-c72b062f0275"),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    tests.api.validate_error_response(response, 404)


@freeze_time("2020-01-01")
def test_applications_get_valid(client, user, auth_token):
    application = ApplicationFactory.create(user=user, updated_time=datetime.now())

    response = client.get(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 200
    response_body = response.get_json().get("data")

    assert response_body.get("employer_fein") is not None
    assert response_body.get("application_id") == str(application.application_id)
    assert response_body.get("updated_time") == "2020-01-01T00:00:00+00:00"
    assert response_body.get("status") == ApplicationStatus.Started.value


def test_applications_unauthorized_get(client, user, auth_token):
    # create application not associated with user
    application = ApplicationFactory.create()

    response = client.get(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    tests.api.validate_error_response(response, 403)


def test_applications_unauthorized_get_with_user(client, user, auth_token):
    other_user = UserFactory.create()
    # create application not associated with user
    application = ApplicationFactory.create(user=other_user)

    response = client.get(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    tests.api.validate_error_response(response, 403)


def test_applications_get_fineos_forbidden(client, fineos_user, fineos_user_token):
    # Fineos role cannot access this endpoint
    application = ApplicationFactory.create(user=fineos_user, updated_time=datetime.now())
    response = client.get(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {fineos_user_token}"},
    )
    assert response.status_code == 403


def test_applications_get_partially_displays_fin_acct_num(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)
    application.payment_preferences = [
        ApplicationPaymentPreference(
            description="Test",
            is_default=True,
            account_name="Foo",
            name_in_check="Bob",
            account_number="123456789",
            routing_number="000987654",
        )
    ]

    test_db_session.commit()

    response = client.get(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")

    payment_preferences = response_body.get("payment_preferences")

    payment_preference = payment_preferences[0]
    assert payment_preference["account_details"]["account_number"] == "*****6789"
    assert payment_preference["account_details"]["routing_number"] == "*********"


def test_applications_get_with_payment_preferences(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    application.payment_preferences = [
        ApplicationPaymentPreference(
            description="Test", is_default=True, account_name="Foo", name_in_check="Bob"
        )
    ]

    test_db_session.commit()

    response = client.get(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    assert response_body.get("application_id") == str(application.application_id)

    payment_preferences = response_body.get("payment_preferences")
    assert payment_preferences
    assert len(payment_preferences) == 1

    payment_preference = payment_preferences[0]
    assert payment_preference["description"] == "Test"
    assert payment_preference["is_default"] is True
    assert payment_preference["account_details"]["account_name"] == "Foo"
    assert payment_preference["cheque_details"]["name_to_print_on_check"] == "Bob"


def test_applications_get_all_for_user(client, user, auth_token):
    applications = [ApplicationFactory.create(user=user), ApplicationFactory.create(user=user)]
    unassociated_application = ApplicationFactory.create()

    response = client.get("/v1/applications", headers={"Authorization": f"Bearer {auth_token}"})
    assert response.status_code == 200

    response_body = response.get_json().get("data")

    for (application, app_response) in zip(applications, response_body):
        assert str(application.application_id) == app_response["application_id"]
        assert application.nickname == app_response["application_nickname"]
        assert application.application_id != unassociated_application.application_id


def test_applications_post_start_app(client, user, auth_token, test_db_session):
    response = client.post("/v1/applications", headers={"Authorization": f"Bearer {auth_token}"})

    response_body = response.get_json().get("data")
    application_id = response_body.get("application_id")

    assert response.status_code == 201
    assert application_id

    application = test_db_session.query(Application).get(application_id)

    assert application.start_time
    assert application.updated_time == application.start_time
    assert application.user.user_id == user.user_id


def test_applications_post_start_app_unauthenticated(client):
    response = client.post("/v1/applications", headers={"Authorization": f"Bearer {''}"})

    tests.api.validate_error_response(response, 401)


def test_applications_post_fineos_forbidden(client, fineos_user_token):
    # Fineos role cannot access this endpoint
    response = client.post(
        "/v1/applications", headers={"Authorization": f"Bearer {fineos_user_token}"}
    )
    assert response.status_code == 403


@freeze_time("2020-01-01")
def test_application_patch(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    update_request_body = sqlalchemy_object_as_dict(application)
    # Change last name
    update_request_body["last_name"] = "Perez"
    update_request_body["leave_details"] = {"relationship_to_caregiver": "Parent"}
    update_request_body["middle_name"] = "Mike"
    update_request_body["tax_identifier"] = "123-45-6789"
    update_request_body["employer_fein"] = "22-7777777"
    update_request_body["occupation"] = "Engineer"

    # Remove foreign keys as DB does not have all tables populated
    update_request_body.pop("employer_id", None)
    update_request_body.pop("employee_id", None)

    update_request_body["mailing_address"] = {
        "city": "Springfield",
        "state": "IL",
        "line_1": "123 Foo St.",
        "zip": "12345-1234",
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    response_body = response.get_json()

    assert response.status_code == 200

    test_db_session.refresh(application)

    # Formatted fields are saved as unformatted (i.e. no dashes)
    assert application.tax_identifier
    assert application.tax_identifier.tax_identifier == "123456789"
    assert application.employer_fein == "227777777"

    assert response_body.get("data").get("last_name") == "Perez"
    assert response_body.get("data").get("updated_time") == "2020-01-01T00:00:00+00:00"
    assert response_body.get("data").get("middle_name") == "Mike"
    assert response_body.get("data").get("occupation") == "Engineer"
    assert response_body.get("data").get("mailing_address")["city"] == "Springfield"

    assert (
        response_body.get("data").get("leave_details").get("relationship_to_caregiver") == "Parent"
    )

    # Formatted / masked fields:
    assert response_body.get("data").get("employer_fein") == "22-7777777"
    assert response_body.get("data").get("tax_identifier") == "***-**-6789"


def test_application_patch_masking(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    update_request_body = {
        "tax_identifier": "123-45-6789",
        "has_state_id": True,
        "mass_id": "123456789",
        "date_of_birth": "1970-01-01",
        "mailing_address": {
            "city": "Chicago",
            "state": "IL",
            "line_1": "123 Foo St.",
            "line_2": "Apt #123",
            "zip": "12345-1234",
        },
        "leave_details": {"child_birth_date": "2021-09-21", "child_placement_date": "2021-05-13"},
        "payment_preferences": [
            {
                "description": "Test",
                "payment_method": "ACH",
                "account_details": {
                    "account_type": "Checking",
                    "routing_number": "000000000",
                    "account_number": "123456789",
                },
            }
        ],
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    response_body = response.get_json()

    assert response.status_code == 200

    # Verify values in the DB are updated and not masked
    test_db_session.refresh(application)
    assert application.tax_identifier.tax_identifier == "123456789"
    assert application.mass_id == "123456789"
    assert application.date_of_birth.isoformat() == "1970-01-01"
    assert application.mailing_address.address_line_one == "123 Foo St."
    assert application.mailing_address.address_line_two == "Apt #123"
    assert application.mailing_address.zip_code == "12345-1234"
    assert application.child_placement_date.isoformat() == "2021-05-13"
    assert application.child_birth_date.isoformat() == "2021-09-21"
    assert application.payment_preferences[0].account_number == "123456789"
    assert application.payment_preferences[0].routing_number == "000000000"

    # Verify values returned by the API are properly masked
    assert response_body.get("data").get("tax_identifier") == "***-**-6789"
    assert response_body.get("data").get("mass_id") == "*********"
    assert response_body.get("data").get("date_of_birth") == "****-01-01"
    assert response_body.get("data").get("mailing_address")["line_1"] == "*******"
    assert response_body.get("data").get("mailing_address")["line_2"] == "*******"
    assert response_body.get("data").get("mailing_address")["zip"] == "12345-****"
    assert (
        response_body.get("data").get("leave_details").get("child_placement_date") == "****-05-13"
    )
    assert response_body.get("data").get("leave_details").get("child_birth_date") == "****-09-21"
    payment_preference = response_body.get("data").get("payment_preferences")[0]
    assert payment_preference["account_details"]["account_number"] == "*****6789"
    assert payment_preference["account_details"]["routing_number"] == "*********"


def test_application_patch_masked_inputs_ignored(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    application.tax_identifier = TaxIdentifier(tax_identifier="123456789")
    application.has_state_id = True
    application.mass_id = "123456789"
    application.date_of_birth = date(1970, 1, 1)
    application.child_birth_date = date(2021, 9, 21)
    application.child_placement_date = date(2021, 5, 13)
    application.payment_preferences = [
        ApplicationPaymentPreference(
            description="Test",
            is_default=True,
            account_name="Foo",
            name_in_check="Bob",
            routing_number="000000000",
            account_number="123456789",
        )
    ]
    application.mailing_address = Address(
        address_line_one="123 Foo St.",
        address_line_two="Apt #123",
        city="Chicago",
        geo_state_id=17,  # Illinois
        zip_code="12345-6789",
    )
    application.residential_address = Address(
        address_line_one="123 Foo St.",
        address_line_two="Apt #123",
        city="Chicago",
        geo_state_id=17,  # Illinois
        zip_code="12345-6789",
    )

    test_db_session.commit()

    update_request_body = {
        "tax_identifier": "***-**-6789",
        "mass_id": "*********",
        "date_of_birth": "****-01-01",
        "leave_details": {"child_birth_date": "****-09-21", "child_placement_date": "****-05-13"},
        "mailing_address": {
            "city": "Chicago",
            "state": "IL",
            "line_1": "*******",
            "line_2": "*******",
            "zip": "12345-****",
        },
        "residential_address": {
            "city": "Chicago",
            "state": "IL",
            "line_1": "*******",
            "line_2": "*******",
            "zip": "12345-****",
        },
        "payment_preferences": [
            {
                "payment_preference_id": application.payment_preferences[0].payment_pref_id,
                "account_details": {"routing_number": "*********", "account_number": "*****6789",},
            }
        ],
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    assert response.status_code == 200

    # Nothing in the DB value was actually updated to the masked value
    test_db_session.refresh(application)
    assert application.tax_identifier.tax_identifier == "123456789"
    assert application.mass_id == "123456789"
    assert application.date_of_birth.isoformat() == "1970-01-01"
    assert application.mailing_address.address_line_one == "123 Foo St."
    assert application.mailing_address.address_line_two == "Apt #123"
    assert application.mailing_address.zip_code == "12345-6789"
    assert application.residential_address.address_line_one == "123 Foo St."
    assert application.residential_address.address_line_two == "Apt #123"
    assert application.residential_address.zip_code == "12345-6789"
    assert application.child_placement_date.isoformat() == "2021-05-13"
    assert application.child_birth_date.isoformat() == "2021-09-21"
    assert application.payment_preferences[0].routing_number == "000000000"
    assert application.payment_preferences[0].account_number == "123456789"


def test_application_patch_masked_mismatch_fields(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    application.tax_identifier = TaxIdentifier(tax_identifier="123456789")
    application.has_state_id = True
    application.mass_id = None
    application.date_of_birth = date(1970, 1, 1)
    application.child_birth_date = date(2021, 9, 21)
    application.child_placement_date = date(2021, 5, 13)
    application.payment_preferences = [
        ApplicationPaymentPreference(
            description="Test",
            is_default=True,
            account_name="Foo",
            name_in_check="Bob",
            routing_number=None,
            account_number="123456789",
        )
    ]
    application.mailing_address = Address(
        address_line_one=None,
        address_line_two=None,
        city="Chicago",
        geo_state_id=17,  # Illinois
        zip_code="12345-6789",
    )
    application.residential_address = Address(
        address_line_one=None,
        address_line_two=None,
        city="Chicago",
        geo_state_id=17,  # Illinois
        zip_code="12345-6789",
    )
    test_db_session.commit()

    update_request_body = {
        "tax_identifier": "***-**-0000",
        "mass_id": "*********",
        "date_of_birth": "****-12-31",
        "leave_details": {"child_birth_date": "****-12-31", "child_placement_date": "****-12-31"},
        "mailing_address": {
            "city": "Chicago",
            "state": "IL",
            "line_1": "*******",
            "line_2": "*******",
            "zip": "55555-****",
        },
        "residential_address": {
            "city": "Chicago",
            "state": "IL",
            "line_1": "*******",
            "line_2": "*******",
            "zip": "55555-****",
        },
        "payment_preferences": [
            {
                "payment_preference_id": application.payment_preferences[0].payment_pref_id,
                "account_details": {"routing_number": "*********", "account_number": "*****0000",},
            }
        ],
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    assert response.status_code == 400
    tests.api.validate_error_response(response, 400, message="Error validating masked fields")
    # Want to make sure every bad value errored above, but the error object is unwieldy, let's just look at the fields.
    fields = set(err["field"] for err in response.get_json()["errors"])
    partially_masked_errors = set(
        [
            "tax_identifier",
            "date_of_birth",
            "leave_details.child_birth_date",
            "leave_details.child_placement_date",
            "mailing_address.zip",
            "residential_address.zip",
            "payment_preferences[0].account_details.account_number",
        ]
    )
    fully_masked_errors = set(
        [
            "mass_id",
            "mailing_address.line_1",
            "mailing_address.line_2",
            "residential_address.line_1",
            "residential_address.line_2",
            "payment_preferences[0].account_details.routing_number",
        ]
    )
    assert fields == partially_masked_errors.union(fully_masked_errors)
    for err in response.get_json()["errors"]:
        assert err["type"] == IssueType.invalid_masked_field

        if err["field"] in partially_masked_errors:
            assert err["rule"] == IssueRule.disallow_mismatched_masked_field
        else:
            assert err["rule"] == IssueRule.disallow_fully_masked_no_existing


def test_application_patch_has_mailing_address(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user, has_mailing_address=None)
    assert application.has_mailing_address is None
    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "has_mailing_address": True,
            "mailing_address": {
                "city": "Chicago",
                "state": "IL",
                "line_1": "123 Foo St.",
                "zip": "12345-1234",
            },
        },
    )
    assert response.status_code == 200
    response_body = response.get_json()
    assert response_body.get("data").get("has_mailing_address") is True
    assert response_body.get("data").get("mailing_address")["line_1"] == "*******"

    test_db_session.refresh(application)
    assert application.has_mailing_address is True
    assert application.mailing_address.address_line_one == "123 Foo St."


def test_application_patch_mailing_address(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    assert application.mailing_address is None

    # adding residential address
    update_request_body = {
        "mailing_address": {
            "city": "Chicago",
            "state": "IL",
            "line_1": "123 Foo St.",
            "zip": "12345-1234",
        }
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    assert response.status_code == 200
    assert response_body.get("data").get("mailing_address")["city"] == "Chicago"
    assert response_body.get("data").get("mailing_address")["line_1"] == "*******"
    assert application.mailing_address.city == "Chicago"
    assert application.mailing_address.address_line_one == "123 Foo St."

    # updating mailing address
    update_request_body = {
        "mailing_address": {
            "city": "Chicago",
            "state": "IL",
            "line_1": "123 Bar St.",
            "line_2": None,
            "zip": "12345-1234",
        }
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    assert response.status_code == 200
    assert response_body.get("data").get("mailing_address")["city"] == "Chicago"
    assert response_body.get("data").get("mailing_address")["line_1"] == "*******"
    assert application.mailing_address.city == "Chicago"
    assert application.mailing_address.address_line_one == "123 Bar St."

    update_request_body_dob = {"date_of_birth": "1970-01-01"}

    # patching another field and confirming mailing address still persists
    response_new_update = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body_dob,
    )

    test_db_session.refresh(application)
    response_body_new_update = response_new_update.get_json()
    assert response_body_new_update.get("data").get("mailing_address")["city"] == "Chicago"
    assert response_body_new_update.get("data").get("mailing_address")["line_1"] == "*******"

    # removing mailing address
    update_request_body = {"mailing_address": None}

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    assert response.status_code == 200
    assert response_body.get("data").get("mailing_address") is None
    assert application.residential_address is None


def test_application_patch_residential_address(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    assert application.residential_address is None

    # adding residential address
    update_request_body = {
        "residential_address": {
            "city": "Chicago",
            "state": "IL",
            "line_1": "123 Foo St.",
            "zip": "12345-1234",
        }
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    assert response.status_code == 200
    assert response_body.get("data").get("residential_address")["city"] == "Chicago"
    assert response_body.get("data").get("residential_address")["line_1"] == "*******"
    assert application.residential_address.city == "Chicago"
    assert application.residential_address.address_line_one == "123 Foo St."

    # updating residential address
    update_request_body = {
        "residential_address": {
            "city": "Chicago",
            "state": "IL",
            "line_1": "123 Bar St.",
            "zip": "12345-1234",
        }
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    assert response.status_code == 200
    assert response_body.get("data").get("residential_address")["city"] == "Chicago"
    assert response_body.get("data").get("residential_address")["line_1"] == "*******"
    assert application.residential_address.city == "Chicago"
    assert application.residential_address.address_line_one == "123 Bar St."

    # removing residential address
    update_request_body = {"residential_address": None}

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    assert response.status_code == 200
    assert response_body.get("data").get("residential_address") is None
    assert application.residential_address is None


def test_application_patch_residential_address_null_values(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)
    assert application.residential_address is None

    # Missing all values
    update_request_body = {
        "residential_address": {"city": None, "state": None, "line_1": None, "zip": None}
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    assert response.status_code == 200
    assert response_body.get("data").get("residential_address") == {}

    # Missing state value
    update_request_body = {
        "residential_address": {
            "city": "Chicago",
            "state": None,
            "line_1": "123 Bar St.",
            "zip": "12345-1234",
        }
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    assert response.status_code == 200
    assert response_body.get("data").get("residential_address") == {}


def test_application_unauthorized_patch(client, user, auth_token, test_db_session):
    # create application not associated with user
    application = ApplicationFactory.create(last_name="Smith")

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"last_name": "Perez"},
    )

    tests.api.validate_error_response(response, 403)

    test_db_session.refresh(application)
    assert application.last_name == "Smith"


def test_application_patch_fineos_forbidden(
    client, fineos_user, fineos_user_token, test_db_session
):
    # Fineos role cannot access this endpoint
    # A fineos user having an application doesn't make sense, but makes certain this fails due to the role.
    application = ApplicationFactory.create(user=fineos_user, last_name="Smith")

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {fineos_user_token}"},
        json={"last_name": "Perez"},
    )

    assert response.status_code == 403

    test_db_session.refresh(application)
    assert application.last_name == "Smith"


def test_application_patch_employee_ssn(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    assert application.tax_identifier
    assert application.tax_identifier.tax_identifier != "123-45-6789"

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"employee_ssn": "123-45-6789"},
    )

    assert response.status_code == 200
    assert response.get_json()["data"]["tax_identifier"] == "***-**-6789"

    test_db_session.refresh(application)
    assert application.tax_identifier
    assert application.tax_identifier.tax_identifier == "123456789"


def test_application_patch_masked_tax_id_has_no_effect(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    tax_identifier_before = application.tax_identifier.tax_identifier

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"employee_ssn": "***-**-****"},
    )

    tests.api.validate_error_response(response, 400)

    test_db_session.refresh(application)
    assert application.tax_identifier
    assert application.tax_identifier.tax_identifier == tax_identifier_before


def test_application_patch_employment_status(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"employment_status": "Employed"},
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    updated_employment_status = response_body.get("employment_status")
    assert updated_employment_status == "Employed"


def test_application_patch_hours_worked_per_week(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"hours_worked_per_week": 50.5},
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    updated_hours_worked_per_week = response_body.get("hours_worked_per_week")
    assert updated_hours_worked_per_week == 50.5


def test_application_patch_pregnant_or_recent_birth(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"leave_details": {"pregnant_or_recent_birth": True}},
    )

    assert response.status_code == 200

    response_body = response.get_json()
    updated_flag = response_body.get("data").get("leave_details").get("pregnant_or_recent_birth")
    assert updated_flag is True


def test_application_patch_child_birth_date(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"leave_details": {"child_birth_date": "2021-09-21"}},
    )

    assert response.status_code == 200

    response_body = response.get_json()
    child_dob = response_body.get("data").get("leave_details").get("child_birth_date")
    assert child_dob == "****-09-21"


def test_application_patch_child_placement_date(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"leave_details": {"child_placement_date": "2021-05-13"}},
    )

    assert response.status_code == 200

    response_body = response.get_json()
    child_dob = response_body.get("data").get("leave_details").get("child_placement_date")
    assert child_dob == "****-05-13"


def test_application_patch_state_id_fields(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"has_state_id": True, "mass_id": "123456789"},
    )

    assert response.status_code == 200

    response_body = response.get_json()
    updated_has_state_id = response_body.get("data").get("has_state_id")
    updated_state_id = response_body.get("data").get("mass_id")
    assert updated_has_state_id is True
    assert updated_state_id == "*********"


def test_application_patch_state_id_fields_good_format(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"has_state_id": True, "mass_id": "S12345678"},
    )

    assert response.status_code == 200

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"has_state_id": True, "mass_id": "SA1234567"},
    )

    assert response.status_code == 200


def test_application_patch_state_id_fields_bad_format(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"has_state_id": True, "mass_id": "123456789000"},
    )

    assert response.status_code == 400

    response_body = response.get_json()
    error = response_body.get("errors")[0]
    assert error["field"] == "mass_id"
    assert (
        error["message"]
        == "'123456789000' does not match '^(\\\\d{9}|S(\\\\d{8}|A\\\\d{7})|(\\\\*{9}))$'"
    )

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"has_state_id": True, "mass_id": "C12345678"},
    )

    assert response.status_code == 400

    response_body = response.get_json()
    error = response_body.get("errors")[0]
    assert error["field"] == "mass_id"
    assert (
        error["message"]
        == "'C12345678' does not match '^(\\\\d{9}|S(\\\\d{8}|A\\\\d{7})|(\\\\*{9}))$'"
    )


def test_application_patch_leave_reason(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    # set to empty value
    application.leave_reason = None
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"leave_details": {"reason": "Serious Health Condition - Employee"}},
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    updated_leave_details = response_body.get("leave_details")
    assert updated_leave_details
    updated_leave_reason = updated_leave_details.get("reason")
    assert updated_leave_reason == "Serious Health Condition - Employee"


def test_application_patch_leave_reason_qualifier(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    # set to empty value
    application.leave_reason = None
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"leave_details": {"reason": "Child Bonding", "reason_qualifier": "Foster Care"}},
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    updated_leave_details = response_body.get("leave_details")
    assert updated_leave_details
    updated_leave_reason = updated_leave_details.get("reason")
    assert updated_leave_reason == "Child Bonding"
    updated_leave_reason_qualifier = updated_leave_details.get("reason_qualifier")
    assert updated_leave_reason_qualifier == "Foster Care"


def test_application_patch_add_leave_period(client, user, auth_token):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "has_continuous_leave_periods": True,
            "has_intermittent_leave_periods": False,
            "has_reduced_schedule_leave_periods": False,
            "leave_details": {"continuous_leave_periods": [{"start_date": "2021-01-01"}]},
        },
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")

    assert response_body.get("has_continuous_leave_periods") is True
    assert response_body.get("has_intermittent_leave_periods") is False
    assert response_body.get("has_reduced_schedule_leave_periods") is False

    updated_leave_details = response_body.get("leave_details")
    assert updated_leave_details

    updated_leave_periods = updated_leave_details.get("continuous_leave_periods")
    assert updated_leave_periods
    assert len(updated_leave_periods) == 1

    updated_leave_period = updated_leave_periods[0]
    assert updated_leave_period["leave_period_id"]
    assert updated_leave_period["start_date"] == "2021-01-01"


def test_application_patch_update_leave_period(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    leave_period = ContinuousLeavePeriod(
        start_date=date(2021, 1, 1), application_id=application.application_id
    )
    test_db_session.add(leave_period)
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "leave_details": {
                "continuous_leave_periods": [
                    {"leave_period_id": leave_period.leave_period_id, "start_date": "2021-01-03"}
                ]
            }
        },
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    updated_leave_details = response_body.get("leave_details")
    assert updated_leave_details

    updated_leave_periods = updated_leave_details.get("continuous_leave_periods")
    assert updated_leave_periods
    assert len(updated_leave_periods) == 1

    updated_leave_period = updated_leave_periods[0]
    assert updated_leave_period["leave_period_id"]
    assert updated_leave_period["start_date"] == "2021-01-03"


def test_application_patch_update_leave_period_belonging_to_other_application_blocked(
    client, user, auth_token, test_db_session
):
    application_1 = ApplicationFactory.create(user=user)
    application_2 = ApplicationFactory.create(user=user)

    leave_period = ContinuousLeavePeriod(
        start_date=date(2021, 6, 11), application_id=application_1.application_id
    )
    test_db_session.add(leave_period)
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application_2.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "leave_details": {
                "continuous_leave_periods": [
                    {"leave_period_id": leave_period.leave_period_id, "start_date": "2021-06-12"}
                ]
            }
        },
    )

    tests.api.validate_error_response(response, 403)

    # assert existing leave period has not changed
    test_db_session.refresh(leave_period)
    assert leave_period.application_id == application_1.application_id
    assert leave_period.start_date == date(2021, 6, 11)

    # assert other application does not have the leave period
    response = client.get(
        "/v1/applications/{}".format(application_2.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    response_body = response.get_json().get("data")
    updated_leave_details = response_body.get("leave_details")
    assert updated_leave_details

    updated_leave_periods = updated_leave_details.get("continuous_leave_periods")
    assert len(updated_leave_periods) == 0


def test_application_patch_add_payment_preferences(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "payment_preferences": [
                {
                    "description": "Test",
                    "payment_method": "ACH",
                    "account_details": {"account_type": "Checking", "routing_number": "000000000",},
                    "cheque_details": {"name_to_print_on_check": "Bob"},
                }
            ]
        },
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    payment_preferences_response = response_body.get("payment_preferences")
    assert len(payment_preferences_response) == 1

    payment_preference = payment_preferences_response[0]
    assert payment_preference.get("description") == "Test"
    assert payment_preference.get("payment_method") == "ACH"
    assert payment_preference.get("account_details").get("account_type") == "Checking"
    assert payment_preference.get("account_details").get("routing_number") == "*********"
    assert payment_preference.get("cheque_details").get("name_to_print_on_check") == "Bob"


def test_application_patch_update_payment_preferences(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    payment_preference = ApplicationPaymentPreference(
        description="Foo", application_id=application.application_id
    )
    test_db_session.add(payment_preference)
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "payment_preferences": [
                {
                    "description": "Bar",
                    "payment_preference_id": payment_preference.payment_pref_id,
                    "account_details": {"routing_number": "121234567",},
                }
            ]
        },
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    payment_preferences_response = response_body.get("payment_preferences")
    assert len(payment_preferences_response) == 1

    payment_preference_response = payment_preferences_response[0]
    assert payment_preference_response["payment_preference_id"] == str(
        payment_preference.payment_pref_id
    )
    assert payment_preference_response["description"] == "Bar"
    assert payment_preference_response["account_details"]["routing_number"] == "*********"

    test_db_session.refresh(payment_preference)
    assert payment_preference.description == "Bar"


def test_application_patch_update_payment_preference_belonging_to_other_application_blocked(
    client, user, auth_token, test_db_session
):
    application_1 = ApplicationFactory.create(user=user)
    application_2 = ApplicationFactory.create(user=user)

    payment_preference = ApplicationPaymentPreference(
        description="Foo", application_id=application_1.application_id
    )
    test_db_session.add(payment_preference)
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application_2.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "payment_preferences": [
                {"payment_preference_id": payment_preference.payment_pref_id, "description": "Bar",}
            ]
        },
    )

    tests.api.validate_error_response(response, 403)

    # assert existing leave period has not changed
    test_db_session.refresh(payment_preference)
    assert payment_preference.application_id == application_1.application_id
    assert payment_preference.description == "Foo"

    # assert other application does not have the leave period
    response = client.get(
        "/v1/applications/{}".format(application_2.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    response_body = response.get_json().get("data")
    payment_preferences_response = response_body.get("payment_preferences")
    assert len(payment_preferences_response) == 0


def test_application_patch_add_work_pattern(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "work_pattern": {
                "work_pattern_type": "Fixed",
                "pattern_start_date": "2021-01-03",
                "work_week_starts": "Sunday",
                "work_pattern_days": [
                    {"day_of_week": "Sunday", "week_number": 1, "minutes": 60 * 8},
                    {"day_of_week": "Monday", "week_number": 1, "minutes": 60 * 8},
                    {"day_of_week": "Tuesday", "week_number": 1, "minutes": 60 * 8},
                    {"day_of_week": "Wednesday", "week_number": 1, "minutes": 60 * 8},
                    {"day_of_week": "Thursday", "week_number": 1, "minutes": 60 * 8},
                    {"day_of_week": "Friday", "week_number": 1, "minutes": 60 * 8},
                    {"day_of_week": "Saturday", "week_number": 1, "minutes": 60 * 8},
                ],
            }
        },
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    work_pattern = response_body.get("work_pattern")

    assert work_pattern.get("work_pattern_type") == "Fixed"
    assert work_pattern.get("pattern_start_date") == "2021-01-03"
    assert work_pattern.get("work_week_starts") == "Sunday"
    assert len(work_pattern.get("work_pattern_days")) == 7


def test_application_patch_update_work_pattern(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    new_work_pattern = WorkPattern(
        pattern_start_date="2021-01-03",
        work_pattern_days=[WorkPatternDay(day_of_week_id=i + 1, week_number=1) for i in range(7)],
    )
    application.work_pattern = new_work_pattern
    test_db_session.add(application)
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "work_pattern": {
                "work_pattern_type": "Fixed",
                "work_week_starts": "Sunday",
                "work_pattern_days": [
                    {"day_of_week": "Sunday", "week_number": 1, "minutes": 60 * 8},
                    {"day_of_week": "Monday", "week_number": 1, "minutes": 60 * 8},
                    {"day_of_week": "Tuesday", "week_number": 1, "minutes": 60 * 8},
                    {"day_of_week": "Wednesday", "week_number": 1, "minutes": 60 * 8},
                    {"day_of_week": "Thursday", "week_number": 1, "minutes": 60 * 8},
                    {"day_of_week": "Friday", "week_number": 1, "minutes": 60 * 8},
                    {"day_of_week": "Saturday", "week_number": 1, "minutes": 60 * 8},
                ],
            }
        },
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    work_pattern = response_body.get("work_pattern")

    assert work_pattern.get("work_pattern_type") == "Fixed"
    assert work_pattern.get("pattern_start_date") == "2021-01-03"
    assert work_pattern.get("work_week_starts") == "Sunday"
    assert len(work_pattern.get("work_pattern_days")) == 7


def test_application_patch_remove_work_pattern_days(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    new_work_pattern = WorkPattern(
        pattern_start_date="2021-01-03",
        work_pattern_type_id=1,
        work_week_starts_id=7,
        work_pattern_days=[WorkPatternDay(day_of_week_id=i + 1, week_number=1) for i in range(7)],
    )
    application.work_pattern = new_work_pattern
    test_db_session.add(application)
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "work_pattern": {
                "work_pattern_type": "Variable",
                "pattern_start_date": None,
                "work_pattern_days": None,
            }
        },
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    work_pattern = response_body.get("work_pattern")

    assert work_pattern.get("work_pattern_type") == "Variable"
    assert work_pattern.get("pattern_start_date") is None
    assert work_pattern.get("work_week_starts") == "Sunday"
    assert len(work_pattern.get("work_pattern_days")) == 0


def test_application_patch_invalid_work_pattern(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    base_work_pattern = {
        "work_pattern_type": "Fixed",
        "work_week_starts": "Sunday",
        "pattern_start_date": "2021-01-03",
        "work_pattern_days": [
            {"day_of_week": "Sunday", "week_number": 1, "minutes": 60 * 8},
            {"day_of_week": "Monday", "week_number": 1, "minutes": 60 * 8},
            {"day_of_week": "Tuesday", "week_number": 1, "minutes": 60 * 8},
            {"day_of_week": "Wednesday", "week_number": 1, "minutes": 60 * 8},
            {"day_of_week": "Thursday", "week_number": 1, "minutes": 60 * 8},
            {"day_of_week": "Friday", "week_number": 1, "minutes": 60 * 8},
            {"day_of_week": "Saturday", "week_number": 1, "minutes": 60 * 8},
        ],
    }

    work_pattern_with_invalid_start_date = copy.deepcopy(base_work_pattern)
    work_pattern_with_invalid_start_date["pattern_start_date"] = "2021-01-04"

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"work_pattern": work_pattern_with_invalid_start_date},
    )

    assert response.status_code == 400
    assert (
        response.get_json().get("detail")
        == "pattern_start_date must be on the same day of the week that the work week starts."
    )

    work_pattern_with_invalid_week_number = copy.deepcopy(base_work_pattern)
    work_pattern_with_invalid_week_number["work_pattern_days"][0]["week_number"] = 5

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"work_pattern": work_pattern_with_invalid_week_number},
    )
    error = response.get_json().get("errors")[0]

    assert response.status_code == 400
    assert error.get("field") == "work_pattern.work_pattern_days.0.week_number"
    assert error.get("message") == "5 is greater than the maximum of 4"
    assert error.get("type") == "maximum"

    work_pattern_with_additional_days = copy.deepcopy(base_work_pattern)
    work_pattern_with_additional_days["work_pattern_days"].append(
        {"day_of_week": "Sunday", "week_number": 1, "minutes": 60 * 8}
    )

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"work_pattern": work_pattern_with_additional_days},
    )

    assert response.status_code == 400
    assert (
        response.get_json().get("detail")
        == "Week number 1 for provided work_pattern_days has 8 days. There should be 7 days."
    )

    work_pattern_with_incomplete_week = copy.deepcopy(base_work_pattern)
    work_pattern_with_incomplete_week["work_pattern_days"].extend(
        [
            {"day_of_week": "Sunday", "week_number": 2, "minutes": 60 * 8},
            {"day_of_week": "Monday", "week_number": 2, "minutes": 60 * 8},
            {"day_of_week": "Wednesday", "week_number": 2, "minutes": 60 * 8},
        ]
    )

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"work_pattern": work_pattern_with_incomplete_week},
    )

    assert response.status_code == 400
    assert (
        response.get_json().get("detail")
        == "Week number 2 for provided work_pattern_days is missing Friday, Saturday, Thursday, Tuesday."
    )

    work_pattern_with_non_consecutive_weeks = copy.deepcopy(base_work_pattern)
    work_pattern_with_non_consecutive_weeks["work_pattern_days"].extend(
        [
            {"day_of_week": "Sunday", "week_number": 3, "minutes": 60 * 8},
            {"day_of_week": "Monday", "week_number": 3, "minutes": 60 * 8},
            {"day_of_week": "Tuesday", "week_number": 3, "minutes": 60 * 8},
            {"day_of_week": "Wednesday", "week_number": 3, "minutes": 60 * 8},
            {"day_of_week": "Thursday", "week_number": 3, "minutes": 60 * 8},
            {"day_of_week": "Friday", "week_number": 3, "minutes": 60 * 8},
            {"day_of_week": "Saturday", "week_number": 3, "minutes": 60 * 8},
        ]
    )

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"work_pattern": work_pattern_with_non_consecutive_weeks},
    )

    assert response.status_code == 400
    assert (
        response.get_json().get("detail")
        == "Week number 2 for provided work_pattern_days has 0 days, but you are attempting to add days for week number 3. All provided weeks should be consecutive."
    )


def test_application_patch_null_date_of_birth(client, user, auth_token):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"date_of_birth": None},
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    dob = response_body.get("date_of_birth")
    assert dob is None


def test_application_patch_date_of_birth_after_1900_over_14(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)

    now = datetime.now()
    test_date = now - relativedelta(years=20)
    test_date_str = test_date.strftime("%Y-%m-%d")

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"date_of_birth": test_date_str},
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    dob = response_body.get("date_of_birth")
    assert dob == f"****{test_date_str[4:]}"

    test_db_session.refresh(application)
    assert application.date_of_birth.isoformat() == test_date_str


def test_application_patch_date_of_birth_under_14(client, user, auth_token):
    application = ApplicationFactory.create(user=user)

    now = datetime.now()
    test_date = now - relativedelta(years=14) + relativedelta(days=1)
    test_date_string = test_date.strftime("%Y-%m-%d")

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"date_of_birth": test_date_string},
    )

    assert response.status_code == 400

    response_body = response.get_json()
    errors = response_body.get("errors")
    assert len(errors) == 1

    error = errors[0]
    field = error.get("field")
    message = error.get("message")
    rule = error.get("rule")
    error_type = error.get("type")

    assert field == "date_of_birth"
    assert message == "The person taking leave must be at least 14 years old"
    assert rule == "older_than_14"
    assert error_type == "invalid_age"


def test_application_patch_date_of_birth_before_1900(client, user, auth_token):
    application = ApplicationFactory.create(user=user)

    now = datetime.now()
    test_date = now.replace(year=1899)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"date_of_birth": test_date.strftime("%Y-%m-%d")},
    )

    assert response.status_code == 400

    response_body = response.get_json()
    errors = response_body.get("errors")
    assert len(errors) == 1

    error = errors[0]
    field = error.get("field")
    message = error.get("message")
    rule = error.get("rule")
    error_type = error.get("type")

    assert field == "date_of_birth"
    assert message == "Date of birth must be within the past 100 years"
    assert rule == "date_of_birth_within_past_100_years"
    assert error_type == "invalid_year_range"


def test_application_patch_date_of_birth_invalid(client, user, auth_token):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "date_of_birth": "1970-13-42",
            "leave_details": {
                "employer_notification_date": "970-06-01",
                "reduced_schedule_leave_periods": [{"end_date": ""}],
            },
        },
    )

    tests.api.validate_error_response(
        response,
        400,
        errors=[
            {"field": "date_of_birth", "message": "invalid date format", "type": "date",},
            {
                "field": "leave_details.reduced_schedule_leave_periods.0.end_date",
                "message": "invalid date format",
                "type": "date",
            },
            {
                "field": "leave_details.employer_notification_date",
                "message": "invalid date format",
                "type": "date",
            },
        ],
    )


def test_application_patch_minimum_payload(client, user, auth_token):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={},
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    data = response_body
    assert application.nickname == data.get("application_nickname")


def test_application_patch_null_values(client, user, auth_token):
    application = ApplicationFactory.create(user=user)

    null_request_body = {
        "application_id": application.application_id,
        "application_nickname": None,
        "tax_identifier": None,
        "employer_fein": None,
        "hours_worked_per_week": None,
        "first_name": None,
        "last_name": None,
        "leave_details": {
            "continuous_leave_periods": [
                {
                    "end_date": None,
                    "end_date_full_day": None,
                    "end_date_off_hours": None,
                    "end_date_off_minutes": None,
                    "expected_return_to_work_date": None,
                    "last_day_worked": None,
                    "start_date": None,
                    "start_date_full_day": None,
                    "start_date_off_hours": None,
                    "start_date_off_minutes": None,
                    "status": None,
                }
            ],
            "child_birth_date": None,
            "child_placement_date": None,
            "employer_notification_date": None,
            "employer_notification_method": None,
            "employer_notified": None,
            "intermittent_leave_periods": [
                {
                    "duration": None,
                    "duration_basis": None,
                    "end_date": None,
                    "frequency": None,
                    "frequency_interval": None,
                    "frequency_interval_basis": None,
                    "start_date": None,
                }
            ],
            "reason": None,
            "reason_qualifier": None,
            "reduced_schedule_leave_periods": [
                {
                    "end_date": None,
                    "friday_off_minutes": None,
                    "monday_off_minutes": None,
                    "saturday_off_minutes": None,
                    "start_date": None,
                    "status": None,
                    "sunday_off_minutes": None,
                    "thursday_off_minutes": None,
                    "tuesday_off_minutes": None,
                    "wednesday_off_minutes": None,
                }
            ],
            "relationship_qualifier": None,
            "relationship_to_caregiver": None,
        },
        "occupation": None,
        "payment_preferences": [
            {
                "account_details": {
                    "account_name": None,
                    "account_number": None,
                    "account_type": None,
                    "routing_number": None,
                },
                "cheque_details": {"name_to_print_on_check": None},
                "description": None,
                "is_default": None,
                "payment_method": None,
            }
        ],
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=null_request_body,
    )

    assert response.get_json().get("warnings")
    assert response.status_code == 200


def test_application_patch_invalid_values(client, user, auth_token):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"leave_details": {"reduced_schedule_leave_periods": {}}},
    )

    tests.api.validate_error_response(response, 400)


def test_application_patch_keys_not_in_body_retain_existing_value(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)

    # establish some existing value
    application.first_name = "Foo"
    test_db_session.commit()

    response = client.get(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    response_body = response.get_json().get("data")

    assert response_body.get("first_name") == "Foo"

    # update some other field
    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"last_name": "Bar"},
    )

    assert response.status_code == 200

    # ensure the existing field still has it's existing value
    test_db_session.refresh(application)
    assert application.first_name == "Foo"

    # for extra measure
    response_body = response.get_json().get("data")
    assert response_body.get("first_name") == "Foo"


def test_application_patch_key_set_to_null_does_null_field(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)

    # establish some existing value
    application.first_name = "Foo"
    test_db_session.commit()

    response = client.get(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    response_body = response.get_json().get("data")
    assert response_body.get("first_name") == "Foo"

    # null the field
    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"first_name": None},
    )

    assert response.status_code == 200

    # ensure it's null in the db
    test_db_session.refresh(application)
    assert application.first_name is None

    # for extra measure
    response_body = response.get_json().get("data")
    assert response_body.get("first_name") is None


def test_application_post_submit_app(client, user, auth_token, test_db_session):
    factory.random.reseed_random(1)
    application = ApplicationFactory.create(user=user)
    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(start_date=date(2021, 1, 1))
    ]
    application.date_of_birth = "1997-06-06"
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.hours_worked_per_week = 70
    application.has_continuous_leave_periods = True
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    # Applications must have an FEIN for submit to succeed.
    application.employer_fein = "770007777"

    assert not application.submitted_time

    test_db_session.commit()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )
    response_body = response.get_json()

    assert response.status_code == 201
    assert not response_body.get("errors")
    assert not response_body.get("warnings")
    # Simplified check to confirm Application was included in response:
    assert response_body.get("data").get("application_id") == str(application.application_id)
    assert response_body.get("data").get("fineos_absence_id") == "NTN-259-ABS-01"
    assert response_body.get("data").get("status") == ApplicationStatus.Submitted.value


def test_application_post_submit_app_already_submitted(client, user, auth_token, test_db_session):
    # This test aims to test the scenario where the application was successfully sent to fineos,
    # but failed when trying to complete the intake. This would mean we have the fineos_absence_id,
    # but it isn't currently in submitted status. This verifies that it only calls methods in complete_intake.
    factory.random.reseed_random(1)
    application = ApplicationFactory.create(user=user)
    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(start_date=date(2021, 1, 1))
    ]
    application.date_of_birth = "1997-06-06"
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.hours_worked_per_week = 70
    application.has_continuous_leave_periods = True
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    # Applications must have an FEIN for submit to succeed.
    application.employer_fein = "770007777"

    # Add fineos_absence_id so it behaves like it was submitted but failed to complete intake
    application.fineos_absence_id = "NTN-259-ABS-01"
    application.fineos_notification_case_id = "NTN-259"

    assert not application.submitted_time

    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )
    response_body = response.get_json()

    assert response.status_code == 201
    assert not response_body.get("errors")
    assert not response_body.get("warnings")
    # Just verify that it was marked as submitted
    assert response_body.get("data").get("status") == ApplicationStatus.Submitted.value

    capture = massgov.pfml.fineos.mock_client.get_capture()
    # This is generated randomly and changes each time.
    fineos_user_id = capture[2][1]
    # Capture contains a find_employer call and the complete_intake call
    assert capture == [
        ("find_employer", None, {"employer_fein": "770007777"}),
        (
            "register_api_user",
            None,
            {
                "employee_registration": massgov.pfml.fineos.models.EmployeeRegistration(
                    user_id=fineos_user_id,
                    customer_number=None,
                    employer_id="7700077771000",
                    date_of_birth=date(1753, 1, 1),
                    email=None,
                    first_name=None,
                    last_name=None,
                    national_insurance_no="105410502",
                )
            },
        ),
        ("complete_intake", fineos_user_id, {"notification_case_id": "NTN-259"},),
    ]


def test_application_post_submit_fineos_forbidden(client, fineos_user, fineos_user_token):
    application = ApplicationFactory.create(user=fineos_user)
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {fineos_user_token}"},
    )

    assert response.status_code == 403


def test_application_post_submit_app_fein_not_found(client, user, auth_token, test_db_session):
    factory.random.reseed_random(2)

    application = ApplicationFactory.create(user=user)
    application.date_of_birth = "1953-01-05"
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.hours_worked_per_week = 70
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(start_date=date(2021, 1, 1))
    ]
    application.has_continuous_leave_periods = True

    assert not application.completed_time

    # A FEIN of 999999999 is simulated as not found in MockFINEOSClient.
    application.employer_fein = "999999999"
    test_db_session.commit()

    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )
    response_body = response.get_json()

    # FINEOS errors are reported back as 503 Service Unavailable.
    assert response.status_code == 503
    assert response_body.get("errors") == []
    assert (
        response_body.get("message")
        == f"Application {str(application.application_id)} could not be submitted, try again later"
    )
    assert not response_body.get("warnings")
    # Simplified check to confirm Application was included in response:
    assert response_body.get("data").get("application_id") == str(application.application_id)
    assert not response_body.get("data").get("fineos_absence_id")
    assert response_body.get("data").get("status") == ApplicationStatus.Started.value


def test_application_post_submit_app_ssn_not_found(client, user, auth_token, test_db_session):
    factory.random.reseed_random(3)

    application = ApplicationFactory.create(user=user)
    application.date_of_birth = "2009-01-20"
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.hours_worked_per_week = 70
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(start_date=date(2021, 1, 1))
    ]
    application.has_continuous_leave_periods = True

    # A tax identifier of 999999999 is simulated as not found in MockFINEOSClient.
    application.tax_identifier = TaxIdentifier(tax_identifier="999999999")

    assert not application.completed_time

    test_db_session.commit()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )
    response_body = response.get_json()

    # FINEOS errors are reported back as 503 Service Unavailable.
    assert response.status_code == 503
    assert response_body.get("errors") == []
    assert (
        response_body.get("message")
        == f"Application {str(application.application_id)} could not be submitted, try again later"
    )
    assert not response_body.get("warnings")
    # Simplified check to confirm Application was included in response:
    assert response_body.get("data").get("application_id") == str(application.application_id)
    assert not response_body.get("data").get("fineos_absence_id")
    assert response_body.get("data").get("status") == ApplicationStatus.Started.value


def test_application_post_submit_existing_work_pattern(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    application.hours_worked_per_week = 70
    application.employer_fein = "770000001"
    application.tax_identifier = TaxIdentifier(tax_identifier="999004444")

    application.first_name = "First"
    application.middle_name = "Middle"
    application.last_name = "Last"
    application.date_of_birth = date(1977, 7, 27)
    application.employer_notified = True
    application.employer_notification_date = date(2021, 1, 7)
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(start_date=date(2021, 1, 1))
    ]
    application.has_continuous_leave_periods = True

    # set fineos user id in DB to avoid autogenerated id
    fineos_user_id = "USER_WITH_EXISTING_WORK_PATTERN"
    fineos_web_id_ext = FINEOSWebIdExt()
    fineos_web_id_ext.employee_tax_identifier = "999004444"
    fineos_web_id_ext.employer_fein = application.employer_fein
    fineos_web_id_ext.fineos_web_id = fineos_user_id
    test_db_session.add(fineos_web_id_ext)

    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()

    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 201

    response_body = response.get_json()
    status = response_body.get("data").get("status")
    assert status == ApplicationStatus.Submitted.value

    capture = massgov.pfml.fineos.mock_client.get_capture()

    # it attempts to add work pattern then updates work pattern
    # causing two queries to fineos in send_to_fineos
    # Then has an additional fineos query in complete_intake
    assert capture[-3:] == [
        (
            "add_week_based_work_pattern",
            fineos_user_id,
            {
                "week_based_work_pattern": massgov.pfml.fineos.models.customer_api.WeekBasedWorkPattern(
                    workPatternType="Fixed",
                    workWeekStarts="Sunday",
                    patternStartDate=None,
                    patternStatus=None,
                    workPatternDays=[
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Monday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Tuesday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Wednesday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Thursday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Friday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Saturday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Sunday", weekNumber=1, hours=8, minutes=15
                        ),
                    ],
                )
            },
        ),
        (
            "update_week_based_work_pattern",
            fineos_user_id,
            {
                "week_based_work_pattern": massgov.pfml.fineos.models.customer_api.WeekBasedWorkPattern(
                    workPatternType="Fixed",
                    workWeekStarts="Sunday",
                    patternStartDate=None,
                    patternStatus=None,
                    workPatternDays=[
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Monday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Tuesday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Wednesday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Thursday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Friday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Saturday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Sunday", weekNumber=1, hours=8, minutes=15
                        ),
                    ],
                )
            },
        ),
        ("complete_intake", "USER_WITH_EXISTING_WORK_PATTERN", {"notification_case_id": "NTN-259"}),
    ]


def test_application_post_submit_to_fineos(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    application.tax_identifier = TaxIdentifier(tax_identifier="999004444")
    application.first_name = "First"
    application.middle_name = "Middle"
    application.last_name = "Last"
    application.date_of_birth = date(1977, 7, 27)
    application.mass_id = "S12345678"
    application.employer_fein = "770000001"
    application.hours_worked_per_week = 70
    application.employer_notified = True
    application.employer_notification_date = date(2021, 1, 7)
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    application.has_continuous_leave_periods = True

    leave_period = ContinuousLeavePeriod(
        start_date=date(2021, 1, 1),
        end_date=date(2021, 2, 9),
        application_id=application.application_id,
    )
    test_db_session.add(leave_period)

    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()

    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 201

    response_body = response.get_json()
    status = response_body.get("data").get("status")
    assert status == ApplicationStatus.Submitted.value

    capture = massgov.pfml.fineos.mock_client.get_capture()

    # This is generated randomly and changes each time.
    fineos_user_id = capture[2][1]
    assert capture == [
        ("find_employer", None, {"employer_fein": "770000001"}),
        (
            "register_api_user",
            None,
            {
                "employee_registration": massgov.pfml.fineos.models.EmployeeRegistration(
                    user_id=fineos_user_id,
                    employer_id="7700000011000",
                    date_of_birth=date(1753, 1, 1),
                    national_insurance_no="999004444",
                )
            },
        ),
        (
            "update_customer_details",
            fineos_user_id,
            {
                "customer": massgov.pfml.fineos.models.customer_api.Customer(
                    firstName="First",
                    lastName="Last",
                    secondName="Middle",
                    dateOfBirth=date(1977, 7, 27),
                    idNumber="999004444",
                    customerAddress=massgov.pfml.fineos.models.customer_api.CustomerAddress(
                        address=massgov.pfml.fineos.models.customer_api.Address(
                            addressLine1=application.residential_address.address_line_one,
                            addressLine2=application.residential_address.address_line_two,
                            addressLine4=application.residential_address.city,
                            addressLine6=application.residential_address.geo_state.geo_state_description,
                            postCode=application.residential_address.zip_code,
                            country="USA",
                        ),
                    ),
                    classExtensionInformation=[
                        massgov.pfml.fineos.models.customer_api.ExtensionAttribute(
                            name="MassachusettsID", stringValue=application.mass_id
                        ),
                        massgov.pfml.fineos.models.customer_api.ExtensionAttribute(
                            name="Confirmed", booleanValue=True
                        ),
                    ],
                )
            },
        ),
        (
            "start_absence",
            fineos_user_id,
            {
                "absence_case": massgov.pfml.fineos.models.customer_api.AbsenceCase(
                    additionalComments="PFML API " + str(application.application_id),
                    intakeSource="Self-Service",
                    notifiedBy="Employee",
                    reason="Serious Health Condition - Employee",
                    reasonQualifier1="Not Work Related",
                    reasonQualifier2="Sickness",
                    primaryRelationship=None,
                    primaryRelQualifier1=None,
                    primaryRelQualifier2=None,
                    timeOffLeavePeriods=[
                        massgov.pfml.fineos.models.customer_api.TimeOffLeavePeriod(
                            startDate=date(2021, 1, 1),
                            endDate=date(2021, 2, 9),
                            lastDayWorked=date(2021, 1, 1),
                            expectedReturnToWorkDate=date(2021, 2, 9),
                            startDateFullDay=True,
                            endDateFullDay=True,
                            status="Known",
                        )
                    ],
                    employerNotified=True,
                    employerNotificationDate=date(2021, 1, 7),
                    employerNotificationMethod=None,
                )
            },
        ),
        ("get_case_occupations", fineos_user_id, {"case_id": "NTN-259"},),
        (
            "add_week_based_work_pattern",
            fineos_user_id,
            {
                "week_based_work_pattern": massgov.pfml.fineos.models.customer_api.WeekBasedWorkPattern(
                    workPatternType="Fixed",
                    workWeekStarts="Sunday",
                    patternStartDate=None,
                    patternStatus=None,
                    workPatternDays=[
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Monday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Tuesday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Wednesday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Thursday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Friday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Saturday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Sunday", weekNumber=1, hours=8, minutes=15
                        ),
                    ],
                )
            },
        ),
        ("complete_intake", fineos_user_id, {"notification_case_id": "NTN-259"}),
    ]


def test_application_post_submit_to_fineos_intermittent_leave(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)

    application.tax_identifier = TaxIdentifier(tax_identifier="999004444")
    application.first_name = "First"
    application.middle_name = "Middle"
    application.last_name = "Last"
    application.date_of_birth = date(1977, 7, 27)
    application.employer_fein = "770000001"
    application.hours_worked_per_week = 70
    application.employer_notified = True
    application.employer_notification_date = date(2021, 1, 7)
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.work_pattern = WorkPatternFixedFactory.create()
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()

    leave_period = IntermittentLeavePeriodFactory.create(
        application_id=application.application_id,
        start_date=date(2021, 1, 1),
        end_date=date(2021, 2, 9),
        frequency_interval=4,
        frequency_interval_basis=FrequencyIntervalBasis.months.value,
        frequency=6,
        duration_basis=DurationBasis.days.value,
        duration=3,
    )

    application.intermittent_leave_periods = [leave_period]
    application.has_intermittent_leave_periods = True

    test_db_session.add(application)

    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()

    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 201

    response_body = response.get_json()
    status = response_body.get("data").get("status")
    assert status == ApplicationStatus.Submitted.value

    capture = massgov.pfml.fineos.mock_client.get_capture()

    assert capture[3][2]["absence_case"].episodicLeavePeriods == [
        massgov.pfml.fineos.models.customer_api.EpisodicLeavePeriod(
            startDate=date(2021, 1, 1),
            endDate=date(2021, 2, 9),
            frequency=6,
            frequencyInterval=4,
            frequencyIntervalBasis="Months",
            duration=3,
            durationBasis="Days",
        )
    ]


def test_application_post_submit_to_fineos_reduced_schedule_leave(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)

    application.tax_identifier = TaxIdentifier(tax_identifier="999004444")
    application.first_name = "First"
    application.middle_name = "Middle"
    application.last_name = "Last"
    application.date_of_birth = date(1977, 7, 27)
    application.employer_fein = "770000001"
    application.hours_worked_per_week = 70
    application.employer_notified = True
    application.employer_notification_date = date(2021, 1, 7)
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.work_pattern = WorkPatternFixedFactory.create()
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()

    leave_period = ReducedScheduleLeavePeriodFactory.create(
        application_id=application.application_id,
        start_date=date(2021, 1, 1),
        end_date=date(2021, 2, 9),
        thursday_off_minutes=240 + 45,
        friday_off_minutes=480,
        saturday_off_minutes=0,
        sunday_off_minutes=45,
        monday_off_minutes=240 + 15,
        tuesday_off_minutes=60,
        wednesday_off_minutes=240 + 30,
    )
    application.reduced_schedule_leave_periods = [leave_period]
    application.has_reduced_schedule_leave_periods = True

    test_db_session.add(application)
    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()

    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 201

    response_body = response.get_json()
    status = response_body.get("data").get("status")
    assert status == ApplicationStatus.Submitted.value

    capture = massgov.pfml.fineos.mock_client.get_capture()

    assert capture[3][2]["absence_case"].reducedScheduleLeavePeriods == [
        massgov.pfml.fineos.models.customer_api.ReducedScheduleLeavePeriod(
            startDate=date(2021, 1, 1),
            endDate=date(2021, 2, 9),
            status="Known",
            mondayOffHours=4,
            mondayOffMinutes=15,
            tuesdayOffHours=1,
            tuesdayOffMinutes=0,
            wednesdayOffHours=4,
            wednesdayOffMinutes=30,
            thursdayOffHours=4,
            thursdayOffMinutes=45,
            fridayOffHours=8,
            fridayOffMinutes=0,
            saturdayOffHours=0,
            saturdayOffMinutes=0,
            sundayOffHours=0,
            sundayOffMinutes=45,
        )
    ]


def test_application_post_submit_to_fineos_bonding_adoption(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)
    application.hours_worked_per_week = 70
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    leave_period = ContinuousLeavePeriod(
        start_date=date(2021, 1, 1),
        end_date=date(2021, 2, 9),
        application_id=application.application_id,
    )
    test_db_session.add(leave_period)

    # Reason = Child Bonding
    # Reason Qualifier 1 = Adoption
    application.leave_reason_id = LeaveReason.CHILD_BONDING.leave_reason_id
    application.leave_reason_qualifier_id = LeaveReasonQualifier.ADOPTION.leave_reason_qualifier_id

    application.child_placement_date = date(2021, 1, 15)
    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )
    assert response.status_code == 201

    capture = massgov.pfml.fineos.mock_client.get_capture()
    captured_absence_case = capture[3][2]["absence_case"]

    assert captured_absence_case.reason == LeaveReason.CHILD_BONDING.leave_reason_description
    assert (
        captured_absence_case.reasonQualifier1
        == LeaveReasonQualifier.ADOPTION.leave_reason_qualifier_description
    )
    assert captured_absence_case.reasonQualifier2 is None
    assert (
        captured_absence_case.primaryRelationship
        == RelationshipToCaregiver.CHILD.relationship_to_caregiver_description
    )
    assert (
        captured_absence_case.primaryRelQualifier1
        == RelationshipQualifier.ADOPTED.relationship_qualifier_description
    )
    assert captured_absence_case.primaryRelQualifier2 is None


def test_application_post_submit_to_fineos_bonding_foster(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)
    application.hours_worked_per_week = 70
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    leave_period = ContinuousLeavePeriod(
        start_date=date(2021, 1, 1),
        end_date=date(2021, 2, 9),
        application_id=application.application_id,
    )
    test_db_session.add(leave_period)

    # Reason = Child Bonding
    # Reason Qualifier 1 = Foster Care
    application.leave_reason_id = LeaveReason.CHILD_BONDING.leave_reason_id
    application.leave_reason_qualifier_id = (
        LeaveReasonQualifier.FOSTER_CARE.leave_reason_qualifier_id
    )
    application.child_placement_date = date(2020, 2, 1)
    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 201

    capture = massgov.pfml.fineos.mock_client.get_capture()
    captured_absence_case = capture[3][2]["absence_case"]

    assert captured_absence_case.reason == LeaveReason.CHILD_BONDING.leave_reason_description
    assert (
        captured_absence_case.reasonQualifier1
        == LeaveReasonQualifier.FOSTER_CARE.leave_reason_qualifier_description
    )
    assert captured_absence_case.reasonQualifier2 is None
    assert (
        captured_absence_case.primaryRelationship
        == RelationshipToCaregiver.CHILD.relationship_to_caregiver_description
    )
    assert (
        captured_absence_case.primaryRelQualifier1
        == RelationshipQualifier.FOSTER.relationship_qualifier_description
    )
    assert captured_absence_case.primaryRelQualifier2 is None


def test_application_post_submit_to_fineos_bonding_newborn(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)
    application.hours_worked_per_week = 70
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    leave_period = ContinuousLeavePeriod(
        start_date=date(2021, 1, 1),
        end_date=date(2021, 2, 9),
        application_id=application.application_id,
    )
    test_db_session.add(leave_period)

    # Reason = Child Bonding
    # Reason Qualifier 1 = Newborn
    application.leave_reason_id = LeaveReason.CHILD_BONDING.leave_reason_id
    application.leave_reason_qualifier_id = LeaveReasonQualifier.NEWBORN.leave_reason_qualifier_id

    application.child_birth_date = date(2020, 2, 1)
    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 201

    capture = massgov.pfml.fineos.mock_client.get_capture()
    captured_absence_case = capture[3][2]["absence_case"]

    assert captured_absence_case.reason == LeaveReason.CHILD_BONDING.leave_reason_description
    assert (
        captured_absence_case.reasonQualifier1
        == LeaveReasonQualifier.NEWBORN.leave_reason_qualifier_description
    )
    assert captured_absence_case.reasonQualifier2 is None
    assert (
        captured_absence_case.primaryRelationship
        == RelationshipToCaregiver.CHILD.relationship_to_caregiver_description
    )
    assert (
        captured_absence_case.primaryRelQualifier1
        == RelationshipQualifier.BIOLOGICAL.relationship_qualifier_description
    )
    assert captured_absence_case.primaryRelQualifier2 is None


def test_application_post_submit_to_fineos_medical(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    application.hours_worked_per_week = 70
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    leave_period = ContinuousLeavePeriod(
        start_date=date(2021, 1, 1),
        end_date=date(2021, 2, 9),
        application_id=application.application_id,
    )
    test_db_session.add(leave_period)

    # API input:
    # Reason = Serious Health Condition - Employee
    # Pregnant or Recent Birth = False
    application.leave_reason_id = LeaveReason.SERIOUS_HEALTH_CONDITION_EMPLOYEE.leave_reason_id
    application.pregnant_or_recent_birth = False
    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 201

    capture = massgov.pfml.fineos.mock_client.get_capture()
    captured_absence_case = capture[3][2]["absence_case"]

    # Maps to FINEOS:
    # Reason = Serious Health Condition - Employee
    # Reason Qualifier 1 = Not Work Related
    # Reason Qualifier 2 = Sickness
    assert (
        captured_absence_case.reason
        == LeaveReason.SERIOUS_HEALTH_CONDITION_EMPLOYEE.leave_reason_description
    )
    assert (
        captured_absence_case.reasonQualifier1
        == LeaveReasonQualifier.NOT_WORK_RELATED.leave_reason_qualifier_description
    )
    assert (
        captured_absence_case.reasonQualifier2
        == LeaveReasonQualifier.SICKNESS.leave_reason_qualifier_description
    )
    assert captured_absence_case.primaryRelationship is None
    assert captured_absence_case.primaryRelQualifier1 is None
    assert captured_absence_case.primaryRelQualifier2 is None


def test_application_post_submit_to_fineos_medical_pregnant(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)
    application.hours_worked_per_week = 70
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    leave_period = ContinuousLeavePeriod(
        start_date=date(2021, 1, 1),
        end_date=date(2021, 2, 9),
        application_id=application.application_id,
    )
    test_db_session.add(leave_period)

    # API input:
    # Reason = Serious Health Condition - Employee
    # Pregnant or Recent Birth = True
    application.leave_reason_id = LeaveReason.SERIOUS_HEALTH_CONDITION_EMPLOYEE.leave_reason_id
    application.pregnant_or_recent_birth = True
    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 201

    capture = massgov.pfml.fineos.mock_client.get_capture()
    captured_absence_case = capture[3][2]["absence_case"]

    # Maps to FINEOS:
    # Reason = Pregnancy/Maternity
    # Reason Qualifier 1 = Postnatal Disability
    assert captured_absence_case.reason == LeaveReason.PREGNANCY_MATERNITY.leave_reason_description
    assert (
        captured_absence_case.reasonQualifier1
        == LeaveReasonQualifier.POSTNATAL_DISABILITY.leave_reason_qualifier_description
    )
    assert captured_absence_case.reasonQualifier2 is None
    assert captured_absence_case.primaryRelationship is None
    assert captured_absence_case.primaryRelQualifier1 is None
    assert captured_absence_case.primaryRelQualifier2 is None


def test_application_post_submit_to_fineos_pregnant(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    application.hours_worked_per_week = 70
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    leave_period = ContinuousLeavePeriod(
        start_date=date(2021, 1, 1),
        end_date=date(2021, 2, 9),
        application_id=application.application_id,
    )
    test_db_session.add(leave_period)

    # API input:
    # Reason = Pregnancy/Maternity
    # Pregnant or Recent Birth = False
    application.leave_reason_id = LeaveReason.PREGNANCY_MATERNITY.leave_reason_id
    application.pregnant_or_recent_birth = False
    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 201

    capture = massgov.pfml.fineos.mock_client.get_capture()
    captured_absence_case = capture[3][2]["absence_case"]

    # Maps to FINEOS:
    # Reason = Pregnancy/Maternity
    # Reason Qualifier 1 = Postnatal Disability
    assert captured_absence_case.reason == LeaveReason.PREGNANCY_MATERNITY.leave_reason_description
    assert (
        captured_absence_case.reasonQualifier1
        == LeaveReasonQualifier.POSTNATAL_DISABILITY.leave_reason_qualifier_description
    )
    assert captured_absence_case.reasonQualifier2 is None
    assert captured_absence_case.primaryRelationship is None
    assert captured_absence_case.primaryRelQualifier1 is None
    assert captured_absence_case.primaryRelQualifier2 is None


def test_application_post_complete_app(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    application.tax_identifier = TaxIdentifier(tax_identifier="999004444")
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.hours_worked_per_week = 70
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    application.employer_fein = "770000001"
    application.fineos_notification_case_id = "NTN-259"
    application.fineos_absence_id = application.fineos_notification_case_id + "-ABS-01"
    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(start_date=date(2021, 1, 1))
    ]
    application.has_continuous_leave_periods = True

    test_db_session.commit()

    response = client.post(
        "/v1/applications/{}/complete_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    response_body = response.get_json()

    assert response.status_code == 200
    assert response_body.get("data").get("status") == ApplicationStatus.Completed.value


def test_application_complete_mark_document_received_fineos(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)
    application.tax_identifier = TaxIdentifier(tax_identifier="999004444")
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.hours_worked_per_week = 70
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    application.employer_fein = "770000001"
    application.fineos_notification_case_id = "NTN-259"
    application.fineos_absence_id = application.fineos_notification_case_id + "-ABS-01"
    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(
            # Dates that pass validation criteria. 55 and 75 are not meaningful values outside
            # of the fact that they are valid. Would work with any valid leave period.
            start_date=datetime.now() + relativedelta(days=55),
            end_date=datetime.now() + relativedelta(days=75),
        )
    ]
    application.has_continuous_leave_periods = True

    test_db_session.add(application)

    id_proof = DocumentFactory.create(
        user_id=user.user_id,
        application_id=application.application_id,
        document_type_id=DocumentType.IDENTIFICATION_PROOF.document_type_id,
        fineos_id="id-proof-dummy-doc-id",
    )
    test_db_session.add(id_proof)

    irrelevant_evidence = DocumentFactory.create(
        user_id=user.user_id,
        application_id=application.application_id,
        document_type_id=DocumentType.PASSPORT.document_type_id,
        fineos_id="passport-dummy-doc-id",
    )
    test_db_session.add(irrelevant_evidence)

    test_db_session.commit()

    assert not application.completed_time

    massgov.pfml.fineos.mock_client.start_capture()

    response = client.post(
        "/v1/applications/{}/complete_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )
    assert response.status_code == 200

    capture = massgov.pfml.fineos.mock_client.get_capture()

    # Refresh the db session because the application object was manipulated by another session
    # in the logic we executed as a result of the POST request above.
    test_db_session.refresh(application)
    assert application.completed_time

    client_function_calls = (
        "find_employer",
        "register_api_user",
        "mark_document_as_received",
    )
    for i in range(len(capture)):
        assert capture[i][0] == client_function_calls[i]

    assert (
        len(capture) == 3
    ), "Did not make 3 requests to FINEOS API. Confirm that we did not attempt to mark_document_as_received for irrelevant_evidence"

    # Function name
    assert capture[2][0] == "mark_document_as_received"

    # Arguments we pass to the function
    assert capture[2][2] == {
        "absence_id": application.fineos_absence_id,
        "fineos_document_id": id_proof.fineos_id,
    }
