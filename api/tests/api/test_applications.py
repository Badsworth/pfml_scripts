import copy
from datetime import date, datetime
from typing import Optional
from unittest import mock

import factory.random
import pytest
from dateutil.relativedelta import relativedelta
from freezegun import freeze_time
from sqlalchemy import inspect

import massgov.pfml.fineos
import massgov.pfml.fineos.mock_client
import massgov.pfml.fineos.models
import massgov.pfml.util.datetime as datetime_util
import tests.api
from massgov.pfml.api.models.applications.common import DurationBasis, FrequencyIntervalBasis
from massgov.pfml.api.models.applications.responses import ApplicationStatus
from massgov.pfml.api.services.fineos_actions import LeaveNotificationReason
from massgov.pfml.api.validation.exceptions import IssueRule, IssueType
from massgov.pfml.db.models.applications import (
    Application,
    ApplicationPaymentPreference,
    ConcurrentLeave,
    ContinuousLeavePeriod,
    DocumentType,
    EmploymentStatus,
    FINEOSWebIdExt,
    LeaveReason,
    LeaveReasonQualifier,
    NoClaimTypeForAbsenceType,
    Phone,
    RelationshipQualifier,
    RelationshipToCaregiver,
    WorkPattern,
    WorkPatternDay,
    WorkPatternType,
)
from massgov.pfml.db.models.employees import Address, Gender, GeoState, PaymentMethod, TaxIdentifier
from massgov.pfml.db.models.factories import (
    AddressFactory,
    ApplicationFactory,
    CaringLeaveMetadataFactory,
    ClaimFactory,
    ConcurrentLeaveFactory,
    ContinuousLeavePeriodFactory,
    DocumentFactory,
    EmployeeFactory,
    EmployerBenefitFactory,
    EmployerFactory,
    IntermittentLeavePeriodFactory,
    LeaveReasonFactory,
    OtherIncomeFactory,
    PreviousLeaveOtherReasonFactory,
    PreviousLeaveSameReasonFactory,
    ReducedScheduleLeavePeriodFactory,
    TaxIdentifierFactory,
    UserFactory,
    WagesAndContributionsFactory,
    WorkPatternFixedFactory,
)
from massgov.pfml.fineos.client import AbstractFINEOSClient
from massgov.pfml.fineos.exception import (
    FINEOSClientError,
    FINEOSEntityNotFound,
    FINEOSFatalResponseError,
    FINEOSFatalUnavailable,
)
from massgov.pfml.fineos.factory import FINEOSClientConfig
from massgov.pfml.util.paginate.paginator import DEFAULT_PAGE_SIZE


def sqlalchemy_object_as_dict(obj):
    return {c.key: getattr(obj, c.key) for c in inspect(obj).mapper.column_attrs}


def test_applications_get_invalid_uuid(client, user, auth_token):
    response = client.get(
        "/v1/applications/undefined", headers={"Authorization": f"Bearer {auth_token}"},
    )

    response_body = response.get_json()
    assert response.status_code == 400
    assert (
        response_body.get("detail")
        == "'undefined' is not a 'uuid'\n\nFailed validating 'format' in schema:\n    {'format': 'uuid', 'type': 'string'}\n\nOn instance:\n    'undefined'"
    )


# The UUID used in this test was generated online. Hopefully it will never match any of
# the IDs generated by our seed data generator. If it does the test will fail.
def test_applications_get_invalid(client, user, auth_token):
    response = client.get(
        "/v1/applications/{}".format("b26aa854-dd50-4aed-906b-c72b062f0275"),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    tests.api.validate_error_response(response, 404)


@freeze_time("2020-01-01")
def test_applications_get_incomplete(client, user, auth_token):
    application = ApplicationFactory.create(
        user=user,
        submitted_time=None,
        updated_at=datetime_util.utcnow(),
        # Cause at least one validation error to be present
        first_name=None,
    )

    response = client.get(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 200
    assert len(response.get_json().get("warnings")) > 0

    response_body = response.get_json().get("data")

    assert response_body.get("employer_fein") is not None
    assert response_body.get("application_id") == str(application.application_id)
    assert response_body.get("updated_at") == "2020-01-01T00:00:00+00:00"
    assert response_body.get("status") == ApplicationStatus.Started.value


def test_applications_get_incomplete_submitted(client, user, auth_token):
    application = ApplicationFactory.create(
        user=user,
        updated_at=datetime_util.utcnow(),
        # Put the application in a state where it is submitted
        submitted_time=datetime_util.utcnow(),
        # Simulate a validation error for pre-submission application
        first_name=None,
    )

    response = client.get(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 200
    # No warning about the first_name missing, because the application is submitted
    assert len(response.get_json().get("warnings")) == 0


def test_applications_unauthorized_get(client, user, auth_token):
    # create application not associated with user
    application = ApplicationFactory.create()

    response = client.get(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    tests.api.validate_error_response(response, 403)


def test_applications_unauthorized_get_with_user(client, user, auth_token):
    other_user = UserFactory.create()
    # create application not associated with user
    application = ApplicationFactory.create(user=other_user)

    response = client.get(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    tests.api.validate_error_response(response, 403)


def test_applications_get_fineos_forbidden(client, fineos_user, fineos_user_token):
    # Fineos role cannot access this endpoint
    application = ApplicationFactory.create(user=fineos_user, updated_at=datetime.now())
    response = client.get(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {fineos_user_token}"},
    )
    tests.api.validate_error_response(response, 403)


def test_applications_get_partially_displays_fin_acct_num(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)
    application.payment_preference = ApplicationPaymentPreference(
        account_number="123456789", routing_number="000987654",
    )

    test_db_session.commit()

    response = client.get(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")

    payment_preference = response_body.get("payment_preference")

    assert payment_preference["account_number"] == "*****6789"
    assert payment_preference["routing_number"] == "*********"


def test_applications_get_with_payment_preference(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    application.payment_preference = ApplicationPaymentPreference(
        payment_method_id=PaymentMethod.ACH.payment_method_id
    )

    test_db_session.commit()

    response = client.get(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    assert response_body.get("application_id") == str(application.application_id)

    payment_preference = response_body.get("payment_preference")
    assert payment_preference

    assert payment_preference["payment_method"] == PaymentMethod.ACH.payment_method_description


def test_applications_get_all_for_user(client, user, auth_token):
    applications = sorted(
        [ApplicationFactory.create(user=user), ApplicationFactory.create(user=user)],
        key=lambda app: app.created_at,
        reverse=True,
    )
    unassociated_application = ApplicationFactory.create()

    response = client.get("/v1/applications", headers={"Authorization": f"Bearer {auth_token}"})
    assert response.status_code == 200

    response_data = response.get_json().get("data")
    assert len(response_data) == len(applications)
    for (application, app_response) in zip(applications, response_data):
        assert str(application.application_id) == app_response["application_id"]
        assert application.nickname == app_response["application_nickname"]
        assert application.application_id != unassociated_application.application_id


def test_applications_get_all_pagination_default_limit(client, user, auth_token):
    applications = [ApplicationFactory.create(user=user) for _ in range(DEFAULT_PAGE_SIZE * 4)]
    applications = sorted(applications, key=lambda app: app.created_at, reverse=True)

    response = client.get("/v1/applications", headers={"Authorization": f"Bearer {auth_token}"})
    assert response.status_code == 200
    response_data = response.get_json().get("data")
    assert len(response_data) == DEFAULT_PAGE_SIZE
    for (application, app_response) in zip(applications, response_data):
        assert str(application.application_id) == app_response["application_id"]
        assert application.nickname == app_response["application_nickname"]


def test_applications_get_all_pagination_asc(client, user, auth_token):
    applications = [ApplicationFactory.create(user=user) for _ in range(100)]
    applications = sorted(applications, key=lambda app: app.created_at, reverse=False)

    response = client.get(
        "/v1/applications?order_direction=ascending",
        headers={"Authorization": f"Bearer {auth_token}"},
    )
    assert response.status_code == 200
    response_data = response.get_json().get("data")
    assert len(response_data) == DEFAULT_PAGE_SIZE
    for (application, app_response) in zip(applications, response_data):
        assert str(application.application_id) == app_response["application_id"]
        assert application.nickname == app_response["application_nickname"]


def test_applications_get_all_pagination_limit_double(client, user, auth_token):
    applications = [ApplicationFactory.create(user=user) for _ in range(DEFAULT_PAGE_SIZE * 4)]
    applications = sorted(applications, key=lambda app: app.created_at, reverse=True)

    response = client.get(
        f"/v1/applications?page_size={DEFAULT_PAGE_SIZE * 2}",
        headers={"Authorization": f"Bearer {auth_token}"},
    )
    assert response.status_code == 200
    response_data = response.get_json().get("data")
    assert len(response_data) == DEFAULT_PAGE_SIZE * 2
    for (application, app_response) in zip(applications, response_data):
        assert str(application.application_id) == app_response["application_id"]
        assert application.nickname == app_response["application_nickname"]


def test_applications_post_start_app(client, user, auth_token, test_db_session):
    response = client.post("/v1/applications", headers={"Authorization": f"Bearer {auth_token}"})

    response_body = response.get_json().get("data")
    application_id = response_body.get("application_id")

    assert response.status_code == 201
    assert application_id

    application = test_db_session.query(Application).get(application_id)

    assert application.created_at
    assert application.updated_at == application.created_at
    assert application.user.user_id == user.user_id


def test_applications_post_start_app_unauthenticated(client):
    response = client.post("/v1/applications", headers={"Authorization": f"Bearer {''}"})

    tests.api.validate_error_response(response, 401)


def test_applications_post_fineos_forbidden(client, fineos_user_token):
    # Fineos role cannot access this endpoint
    response = client.post(
        "/v1/applications", headers={"Authorization": f"Bearer {fineos_user_token}"}
    )
    assert response.status_code == 403


@freeze_time("2020-01-01")
def test_application_patch(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    update_request_body = sqlalchemy_object_as_dict(application)
    # Change last name
    update_request_body["last_name"] = "Perez"
    update_request_body["leave_details"] = {
        "employer_notification_method": "In Writing",
        "caring_leave_metadata": {
            "family_member_first_name": "Jane",
            "family_member_middle_name": "Alice",
            "family_member_last_name": "Doe",
            "family_member_date_of_birth": "1975-01-01",
            "relationship_to_caregiver": RelationshipToCaregiver.PARENT.relationship_to_caregiver_description,
        },
    }
    update_request_body["middle_name"] = "Mike"
    update_request_body["tax_identifier"] = "123-45-6789"
    update_request_body["employer_fein"] = "22-7777777"
    update_request_body["occupation"] = "Engineer"

    # Remove foreign keys as DB does not have all tables populated
    update_request_body.pop("employer_id", None)
    update_request_body.pop("employee_id", None)

    update_request_body["mailing_address"] = {
        "city": "Springfield",
        "state": "IL",
        "line_1": "123 Foo St.",
        "zip": "12345-1234",
    }

    update_request_body["phone"] = {
        "int_code": "1",
        "phone_number": "240-487-9945",
        "phone_type": "Cell",
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    response_body = response.get_json()

    assert response.status_code == 200

    test_db_session.refresh(application)

    # Formatted fields are saved as unformatted (i.e. no dashes)
    assert application.tax_identifier
    assert application.tax_identifier.tax_identifier == "123456789"
    assert application.employer_fein == "227777777"

    # CaringLeaveMetadata fields added
    assert application.caring_leave_metadata.family_member_first_name == "Jane"
    assert application.caring_leave_metadata.family_member_middle_name == "Alice"
    assert application.caring_leave_metadata.family_member_last_name == "Doe"
    assert application.caring_leave_metadata.family_member_date_of_birth.isoformat() == "1975-01-01"
    assert (
        application.caring_leave_metadata.relationship_to_caregiver_id
        == RelationshipToCaregiver.PARENT.relationship_to_caregiver_id
    )

    # Phone number is saved as E.164
    assert application.phone.phone_number == "+12404879945"

    assert response_body.get("data").get("last_name") == "Perez"
    assert response_body.get("data").get("updated_at") == "2020-01-01T00:00:00+00:00"
    assert response_body.get("data").get("middle_name") == "Mike"
    assert response_body.get("data").get("occupation") == "Engineer"
    assert response_body.get("data").get("mailing_address")["city"] == "Springfield"
    assert response_body.get("data").get("phone")["phone_type"] == "Cell"

    assert (
        response_body.get("data").get("leave_details").get("employer_notification_method")
        == "In Writing"
    )

    assert (
        response_body.get("data")
        .get("leave_details")
        .get("caring_leave_metadata")["family_member_first_name"]
        == "Jane"
    )
    assert (
        response_body.get("data")
        .get("leave_details")
        .get("caring_leave_metadata")["family_member_middle_name"]
        == "Alice"
    )
    assert (
        response_body.get("data")
        .get("leave_details")
        .get("caring_leave_metadata")["family_member_last_name"]
        == "Doe"
    )
    assert (
        response_body.get("data")
        .get("leave_details")
        .get("caring_leave_metadata")["relationship_to_caregiver"]
        == RelationshipToCaregiver.PARENT.relationship_to_caregiver_description
    )

    # Formatted / masked fields:
    assert response_body.get("data").get("employer_fein") == "22-7777777"
    assert response_body.get("data").get("tax_identifier") == "***-**-6789"
    assert response_body.get("data").get("phone")["phone_number"] == "***-***-9945"
    assert (
        response_body.get("data")
        .get("leave_details")
        .get("caring_leave_metadata")["family_member_date_of_birth"]
        == "****-01-01"
    )


def test_application_patch_masking(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    update_request_body = {
        "tax_identifier": "123-45-6789",
        "has_state_id": True,
        "mass_id": "123456789",
        "date_of_birth": "1970-01-01",
        "mailing_address": {
            "city": "Chicago",
            "state": "IL",
            "line_1": "123 Foo St.",
            "line_2": "Apt #123",
            "zip": "12345-1234",
        },
        "leave_details": {
            "child_birth_date": "2021-09-21",
            "child_placement_date": "2021-05-13",
            "caring_leave_metadata": {"family_member_date_of_birth": "2021-01-01"},
        },
        "phone": {"int_code": "1", "phone_number": "240-487-9945", "phone_type": "Cell",},
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    response_body = response.get_json()

    assert response.status_code == 200

    # Verify values in the DB are updated and not masked
    test_db_session.refresh(application)
    assert application.tax_identifier.tax_identifier == "123456789"
    assert application.mass_id == "123456789"
    assert application.date_of_birth.isoformat() == "1970-01-01"
    assert application.mailing_address.address_line_one == "123 Foo St."
    assert application.mailing_address.address_line_two == "Apt #123"
    assert application.mailing_address.zip_code == "12345-1234"
    assert application.child_placement_date.isoformat() == "2021-05-13"
    assert application.child_birth_date.isoformat() == "2021-09-21"
    assert application.phone.phone_number == "+12404879945"
    assert application.caring_leave_metadata.family_member_date_of_birth.isoformat() == "2021-01-01"

    # Verify values returned by the API are properly masked
    assert response_body.get("data").get("tax_identifier") == "***-**-6789"
    assert response_body.get("data").get("mass_id") == "*********"
    assert response_body.get("data").get("date_of_birth") == "****-01-01"
    assert response_body.get("data").get("mailing_address")["line_1"] == "*******"
    assert response_body.get("data").get("mailing_address")["line_2"] == "*******"
    assert response_body.get("data").get("mailing_address")["zip"] == "12345-****"
    assert (
        response_body.get("data").get("leave_details").get("child_placement_date") == "****-05-13"
    )
    assert response_body.get("data").get("leave_details").get("child_birth_date") == "****-09-21"
    assert (
        response_body.get("data")
        .get("leave_details")
        .get("caring_leave_metadata")["family_member_date_of_birth"]
        == "****-01-01"
    )
    assert response_body.get("data").get("phone")["phone_number"] == "***-***-9945"


def test_application_patch_masked_inputs_ignored(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    application.tax_identifier = TaxIdentifier(tax_identifier="123456789")
    application.has_state_id = True
    application.mass_id = "123456789"
    application.date_of_birth = date(1970, 1, 1)
    application.child_birth_date = date(2021, 9, 21)
    application.child_placement_date = date(2021, 5, 13)
    application.payment_preference = ApplicationPaymentPreference(
        routing_number="000000000", account_number="123456789",
    )
    application.mailing_address = Address(
        address_line_one="123 Foo St.",
        address_line_two="Apt #123",
        city="Chicago",
        geo_state_id=17,  # Illinois
        zip_code="12345-6789",
    )
    application.residential_address = Address(
        address_line_one="123 Foo St.",
        address_line_two="Apt #123",
        city="Chicago",
        geo_state_id=17,  # Illinois
        zip_code="12345-6789",
    )
    application.phone = Phone(phone_number="+12404879945", phone_type_id=1)  # Cell

    caring_leave_metadata = CaringLeaveMetadataFactory.create(
        family_member_date_of_birth=date(1975, 1, 1)
    )

    application.caring_leave_metadata = caring_leave_metadata

    test_db_session.add(caring_leave_metadata)

    test_db_session.commit()

    update_request_body = {
        "tax_identifier": "***-**-6789",
        "mass_id": "*********",
        "date_of_birth": "****-01-01",
        "leave_details": {
            "child_birth_date": "****-09-21",
            "child_placement_date": "****-05-13",
            "caring_leave_metadata": {"family_member_date_of_birth": "****-01-01"},
        },
        "mailing_address": {
            "city": "Chicago",
            "state": "IL",
            "line_1": "*******",
            "line_2": "*******",
            "zip": "12345-****",
        },
        "residential_address": {
            "city": "Chicago",
            "state": "IL",
            "line_1": "*******",
            "line_2": "*******",
            "zip": "12345-****",
        },
        "phone": {"int_code": "1", "phone_number": "***-***-9945", "phone_type": "Cell"},
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    assert response.status_code == 200

    # Nothing in the DB value was actually updated to the masked value
    test_db_session.refresh(application)
    assert application.tax_identifier.tax_identifier == "123456789"
    assert application.mass_id == "123456789"
    assert application.date_of_birth.isoformat() == "1970-01-01"
    assert application.mailing_address.address_line_one == "123 Foo St."
    assert application.mailing_address.address_line_two == "Apt #123"
    assert application.mailing_address.zip_code == "12345-6789"
    assert application.residential_address.address_line_one == "123 Foo St."
    assert application.residential_address.address_line_two == "Apt #123"
    assert application.residential_address.zip_code == "12345-6789"
    assert application.child_placement_date.isoformat() == "2021-05-13"
    assert application.child_birth_date.isoformat() == "2021-09-21"
    assert application.phone.phone_number == "+12404879945"
    assert application.caring_leave_metadata.family_member_date_of_birth.isoformat() == "1975-01-01"


def test_application_patch_masked_mismatch_fields(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    application.tax_identifier = TaxIdentifier(tax_identifier="123456789")
    application.has_state_id = True
    application.mass_id = None
    application.date_of_birth = date(1970, 1, 1)
    application.child_birth_date = date(2021, 9, 21)
    application.child_placement_date = date(2021, 5, 13)

    application.mailing_address = Address(
        address_line_one=None,
        address_line_two=None,
        city="Chicago",
        geo_state_id=17,  # Illinois
        zip_code="12345-6789",
    )
    application.residential_address = Address(
        address_line_one=None,
        address_line_two=None,
        city="Chicago",
        geo_state_id=17,  # Illinois
        zip_code="12345-6789",
    )
    application.phone = Phone(phone_number="+2404879945", phone_type_id=1)  # Cell

    test_db_session.commit()

    update_request_body = {
        "tax_identifier": "***-**-0000",
        "mass_id": "*********",
        "date_of_birth": "****-12-31",
        "leave_details": {"child_birth_date": "****-12-31", "child_placement_date": "****-12-31"},
        "mailing_address": {
            "city": "Chicago",
            "state": "IL",
            "line_1": "*******",
            "line_2": "*******",
            "zip": "55555-****",
        },
        "residential_address": {
            "city": "Chicago",
            "state": "IL",
            "line_1": "*******",
            "line_2": "*******",
            "zip": "55555-****",
        },
        "phone": {"int_code": "1", "phone_number": "***-***-1234", "phone_type": "Cell",},
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    assert response.status_code == 400
    tests.api.validate_error_response(response, 400, message="Error validating masked fields")
    # Want to make sure every bad value errored above, but the error object is unwieldy, let's just look at the fields.
    fields = set(err["field"] for err in response.get_json()["errors"])
    partially_masked_errors = set(
        [
            "tax_identifier",
            "date_of_birth",
            "leave_details.child_birth_date",
            "leave_details.child_placement_date",
            "mailing_address.zip",
            "residential_address.zip",
            "phone.phone_number",
        ]
    )
    fully_masked_errors = set(
        [
            "mass_id",
            "mailing_address.line_1",
            "mailing_address.line_2",
            "residential_address.line_1",
            "residential_address.line_2",
        ]
    )
    assert fields == partially_masked_errors.union(fully_masked_errors)
    for err in response.get_json()["errors"]:
        assert err["type"] == IssueType.invalid_masked_field

        if err["field"] in partially_masked_errors:
            assert err["rule"] == IssueRule.disallow_mismatched_masked_field
        else:
            assert err["rule"] == IssueRule.disallow_fully_masked_no_existing


def test_application_patch_has_mailing_address(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user, has_mailing_address=None)
    assert application.has_mailing_address is None
    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "has_mailing_address": True,
            "mailing_address": {
                "city": "Chicago",
                "state": "IL",
                "line_1": "123 Foo St.",
                "zip": "12345-1234",
            },
        },
    )
    assert response.status_code == 200
    response_body = response.get_json()
    assert response_body.get("data").get("has_mailing_address") is True
    assert response_body.get("data").get("mailing_address")["line_1"] == "*******"

    test_db_session.refresh(application)
    assert application.has_mailing_address is True
    assert application.mailing_address.address_line_one == "123 Foo St."


def test_application_patch_mailing_address(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    assert application.mailing_address is None

    # adding residential address
    update_request_body = {
        "mailing_address": {
            "city": "Chicago",
            "state": "IL",
            "line_1": "123 Foo St.",
            "zip": "12345-1234",
        }
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    assert response.status_code == 200
    assert response_body.get("data").get("mailing_address")["city"] == "Chicago"
    assert response_body.get("data").get("mailing_address")["line_1"] == "*******"
    assert application.mailing_address.city == "Chicago"
    assert application.mailing_address.address_line_one == "123 Foo St."

    # updating mailing address
    update_request_body = {
        "mailing_address": {
            "city": "Chicago",
            "state": "IL",
            "line_1": "123 Bar St.",
            "line_2": None,
            "zip": "12345-1234",
        }
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    assert response.status_code == 200
    assert response_body.get("data").get("mailing_address")["city"] == "Chicago"
    assert response_body.get("data").get("mailing_address")["line_1"] == "*******"
    assert application.mailing_address.city == "Chicago"
    assert application.mailing_address.address_line_one == "123 Bar St."

    update_request_body_dob = {"date_of_birth": "1970-01-01"}

    # patching a partial update of the mailing address (zip code only)
    update_request_body = {"mailing_address": {"zip": "12345",}}

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    assert response.status_code == 200
    assert response_body.get("data").get("mailing_address")["city"] == "Chicago"
    assert response_body.get("data").get("mailing_address")["line_1"] == "*******"
    assert response_body.get("data").get("mailing_address")["zip"] == "12345"
    assert application.mailing_address.city == "Chicago"
    assert application.mailing_address.address_line_one == "123 Bar St."
    assert application.mailing_address.zip_code == "12345"

    # patching another field and confirming mailing address still persists
    response_new_update = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body_dob,
    )

    test_db_session.refresh(application)
    response_body_new_update = response_new_update.get_json()
    assert response_body_new_update.get("data").get("mailing_address")["city"] == "Chicago"
    assert response_body_new_update.get("data").get("mailing_address")["line_1"] == "*******"

    # removing mailing address
    update_request_body = {"mailing_address": None}

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    assert response.status_code == 200
    assert response_body.get("data").get("mailing_address") is None
    assert application.residential_address is None


def test_application_patch_residential_address(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    assert application.residential_address is None

    # adding residential address
    update_request_body = {
        "residential_address": {
            "city": "Chicago",
            "state": "IL",
            "line_1": "123 Foo St.",
            "zip": "12345-1234",
        }
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    assert response.status_code == 200
    assert response_body.get("data").get("residential_address")["city"] == "Chicago"
    assert response_body.get("data").get("residential_address")["line_1"] == "*******"
    assert application.residential_address.city == "Chicago"
    assert application.residential_address.address_line_one == "123 Foo St."

    # updating residential address
    update_request_body = {
        "residential_address": {
            "city": "Chicago",
            "state": "IL",
            "line_1": "123 Bar St.",
            "zip": "12345-1234",
        }
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    assert response.status_code == 200
    assert response_body.get("data").get("residential_address")["city"] == "Chicago"
    assert response_body.get("data").get("residential_address")["line_1"] == "*******"
    assert application.residential_address.city == "Chicago"
    assert application.residential_address.address_line_one == "123 Bar St."

    # patching a partial update of the residential address (zip code only)
    update_request_body = {"residential_address": {"zip": "12345",}}

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    assert response.status_code == 200
    assert response_body.get("data").get("residential_address")["city"] == "Chicago"
    assert response_body.get("data").get("residential_address")["line_1"] == "*******"
    assert response_body.get("data").get("residential_address")["zip"] == "12345"
    assert application.residential_address.city == "Chicago"
    assert application.residential_address.address_line_one == "123 Bar St."
    assert application.residential_address.zip_code == "12345"

    # removing residential address
    update_request_body = {"residential_address": None}

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    assert response.status_code == 200
    assert response_body.get("data").get("residential_address") is None
    assert application.residential_address is None


def test_application_patch_residential_address_null_values(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)
    assert application.residential_address is None

    # Missing all values
    update_request_body = {
        "residential_address": {"city": None, "state": None, "line_1": None, "zip": None}
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    assert response.status_code == 200
    assert response_body.get("data").get("residential_address") == {}

    # Missing state value
    update_request_body = {
        "residential_address": {
            "city": "Chicago",
            "state": None,
            "line_1": "123 Bar St.",
            "zip": "12345-1234",
        }
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    assert response.status_code == 200
    assert response_body.get("data").get("residential_address").get("state") is None


def test_application_patch_residential_address_line_2_masked(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)
    application.residential_address = Address(
        address_line_one="Mt. Greylock",
        address_line_two="Taconic Mountains",
        city="Adams",
        geo_state_id=GeoState.MA.geo_state_id,
        zip_code="01220",
    )
    test_db_session.commit()

    assert application.residential_address
    assert application.residential_address.address_line_two

    # 1. Update the address by removing the second line. Perhaps the applicant realized they were being too specific.
    first_update_request_body = {
        "residential_address": {
            "line_1": "Mt. Greylock",
            "line_2": "",
            "city": "Adams",
            "state": "MA",
            "zip": "01220",
        }
    }

    first_update_response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=first_update_request_body,
    )
    assert first_update_response.status_code == 200

    # 2. Get the latest fields for the application before we update the address again.
    get_response = client.get(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )
    get_response_body = get_response.get_json()
    addr = get_response_body["data"]["residential_address"]

    assert get_response.status_code == 200
    assert not addr["line_2"]

    # 3. Update the first address line. Use the second address line field from the response to emulate not changing it.
    second_update_request_body = {
        "residential_address": {
            "line_1": "Mount Greylock",
            "line_2": addr["line_2"],
            "city": "Adams",
            "state": "MA",
            "zip": "01220",
        }
    }
    second_update_response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=second_update_request_body,
    )
    assert second_update_response.status_code == 200

    errors = second_update_response.get_json().get("errors")
    assert not errors


def test_application_patch_phone(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user, phone=None)
    assert application.phone is None

    # adding phone
    update_request_body = {
        "phone": {"phone_number": "240-487-9945", "phone_type": "Cell", "int_code": "1"}
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    assert response.status_code == 200
    response_phone = response_body.get("data").get("phone")
    assert application.phone.phone_number == "+12404879945"
    assert application.phone.phone_type_id == 1  # Cell
    assert response_phone["phone_number"] == "***-***-9945"
    assert response_phone["phone_type"] == update_request_body["phone"]["phone_type"]
    assert response_phone["int_code"] == update_request_body["phone"]["int_code"]

    # updating phone
    update_request_body = {
        "phone": {"phone_number": "240-487-1234", "phone_type": "Phone", "int_code": "1"}
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    assert application.phone.phone_number == "+12404871234"
    assert application.phone.phone_type_id == 3  # Phone
    response_body = response.get_json()
    assert response.status_code == 200
    response_phone = response_body.get("data").get("phone")
    assert response_phone["phone_number"] == "***-***-1234"
    assert response_phone["phone_type"] == update_request_body["phone"]["phone_type"]

    update_request_body_dob = {"date_of_birth": "1970-01-01"}

    # patching another field and confirming phone still persists
    response_new_update = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body_dob,
    )

    test_db_session.refresh(application)
    assert application.phone.phone_number == "+12404871234"
    assert application.phone.phone_type_id == 3  # Phone
    response_body_new_update = response_new_update.get_json()
    response_phone = response_body_new_update.get("data").get("phone")
    assert response_phone["phone_number"] == "***-***-1234"
    assert response_phone["phone_type"] == update_request_body["phone"]["phone_type"]

    # patching with a masked value doesn't change the existing database value

    update_request_masked_phone_number = {
        "phone": {"phone_number": "***-***-1234", "int_code": "1", "phone_type": "Cell"}
    }

    response_new_update = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_masked_phone_number,
    )

    test_db_session.refresh(application)
    assert application.phone.phone_number == "+12404871234"
    assert application.phone.phone_type_id == 1  # Cell
    response_body_new_update = response_new_update.get_json()
    response_phone = response_body_new_update.get("data").get("phone")
    assert response_phone["phone_number"] == "***-***-1234"
    assert response_phone["phone_type"] == update_request_masked_phone_number["phone"]["phone_type"]


def test_application_patch_phone_validation(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user, phone=None)
    assert application.phone is None

    # adding an invalid phone number (fake area code)
    update_request_body = {
        "phone": {"phone_number": "123-456-7890", "phone_type": "Cell", "int_code": "1"}
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    error = response_body.get("errors")[0]
    assert response.status_code == 400
    assert error["field"] == "phone.phone_number"
    assert error["message"] == "Phone number must be a valid number"


def test_application_unauthorized_patch(client, user, auth_token, test_db_session):
    # create application not associated with user
    application = ApplicationFactory.create(last_name="Smith")

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"last_name": "Perez"},
    )

    tests.api.validate_error_response(response, 403)

    test_db_session.refresh(application)
    assert application.last_name == "Smith"


def test_application_patch_fineos_forbidden(
    client, fineos_user, fineos_user_token, test_db_session
):
    # Fineos role cannot access this endpoint
    # A fineos user having an application doesn't make sense, but makes certain this fails due to the role.
    application = ApplicationFactory.create(user=fineos_user, last_name="Smith")

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {fineos_user_token}"},
        json={"last_name": "Perez"},
    )

    assert response.status_code == 403

    test_db_session.refresh(application)
    assert application.last_name == "Smith"


def test_application_patch_tax_identifier(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    assert application.tax_identifier
    assert application.tax_identifier.tax_identifier != "123-45-6789"

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"tax_identifier": "123-45-6789"},
    )

    assert response.status_code == 200
    assert response.get_json()["data"]["tax_identifier"] == "***-**-6789"

    test_db_session.refresh(application)
    assert application.tax_identifier
    assert application.tax_identifier.tax_identifier == "123456789"


def test_application_patch_masked_tax_id_has_no_effect(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    tax_identifier_before = application.tax_identifier.tax_identifier

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"tax_identifier": "***-**-****"},
    )

    tests.api.validate_error_response(response, 400)

    test_db_session.refresh(application)
    assert application.tax_identifier
    assert application.tax_identifier.tax_identifier == tax_identifier_before


def test_application_patch_employment_status(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"employment_status": "Employed"},
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    updated_employment_status = response_body.get("employment_status")
    assert updated_employment_status == "Employed"


def test_application_patch_hours_worked_per_week(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"hours_worked_per_week": 50.5},
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    updated_hours_worked_per_week = response_body.get("hours_worked_per_week")
    assert updated_hours_worked_per_week == 50.5


def test_application_patch_pregnant_or_recent_birth(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"leave_details": {"pregnant_or_recent_birth": True}},
    )

    assert response.status_code == 200

    response_body = response.get_json()
    updated_flag = response_body.get("data").get("leave_details").get("pregnant_or_recent_birth")
    assert updated_flag is True


def test_application_patch_child_birth_date(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"leave_details": {"child_birth_date": "2021-09-21"}},
    )

    assert response.status_code == 200

    response_body = response.get_json()
    child_dob = response_body.get("data").get("leave_details").get("child_birth_date")
    assert child_dob == "****-09-21"


def test_application_patch_child_placement_date(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"leave_details": {"child_placement_date": "2021-05-13"}},
    )

    assert response.status_code == 200

    response_body = response.get_json()
    child_dob = response_body.get("data").get("leave_details").get("child_placement_date")
    assert child_dob == "****-05-13"


def test_application_patch_has_future_child_date(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user, has_future_child_date=None)
    assert application.has_future_child_date is None
    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"leave_details": {"has_future_child_date": True,}},
    )
    assert response.status_code == 200
    response_body = response.get_json()
    response_leave_details = response_body.get("data").get("leave_details")
    assert response_leave_details
    assert response_leave_details.get("has_future_child_date") is True

    test_db_session.refresh(application)
    assert application.has_future_child_date is True


def test_application_patch_state_id_fields(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"has_state_id": True, "mass_id": "123456789"},
    )

    assert response.status_code == 200

    response_body = response.get_json()
    updated_has_state_id = response_body.get("data").get("has_state_id")
    updated_state_id = response_body.get("data").get("mass_id")
    assert updated_has_state_id is True
    assert updated_state_id == "*********"


def test_application_patch_state_id_fields_good_format(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"has_state_id": True, "mass_id": "S12345678"},
    )

    assert response.status_code == 200

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"has_state_id": True, "mass_id": "SA1234567"},
    )

    assert response.status_code == 200


def test_application_patch_state_id_fields_bad_format(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"has_state_id": True, "mass_id": "123456789000"},
    )

    assert response.status_code == 400

    response_body = response.get_json()
    error = response_body.get("errors")[0]
    assert error["field"] == "mass_id"
    assert (
        error["message"]
        == "'123456789000' does not match '^(\\\\d{9}|S(\\\\d{8}|A\\\\d{7})|(\\\\*{9}))$'"
    )

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"has_state_id": True, "mass_id": "C12345678"},
    )

    assert response.status_code == 400

    response_body = response.get_json()
    error = response_body.get("errors")[0]
    assert error["field"] == "mass_id"
    assert (
        error["message"]
        == "'C12345678' does not match '^(\\\\d{9}|S(\\\\d{8}|A\\\\d{7})|(\\\\*{9}))$'"
    )


def test_application_patch_leave_reason(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    # set to empty value
    application.leave_reason = None
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"leave_details": {"reason": "Serious Health Condition - Employee"}},
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    updated_leave_details = response_body.get("leave_details")
    assert updated_leave_details
    updated_leave_reason = updated_leave_details.get("reason")
    assert updated_leave_reason == "Serious Health Condition - Employee"


def test_application_patch_leave_reason_qualifier(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    # set to empty value
    application.leave_reason = None
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"leave_details": {"reason": "Child Bonding", "reason_qualifier": "Foster Care"}},
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    updated_leave_details = response_body.get("leave_details")
    assert updated_leave_details
    updated_leave_reason = updated_leave_details.get("reason")
    assert updated_leave_reason == "Child Bonding"
    updated_leave_reason_qualifier = updated_leave_details.get("reason_qualifier")
    assert updated_leave_reason_qualifier == "Foster Care"


def test_application_patch_update_leave_reason_and_delete_leave_reason_qualifier(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)

    # set an initial value
    application.leave_reason_id = LeaveReason.CHILD_BONDING.leave_reason_id
    application.leave_reason_qualifier_id = LeaveReasonQualifier.NEWBORN.leave_reason_qualifier_id
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "leave_details": {
                "reason": "Serious Health Condition - Employee",
                "reason_qualifier": None,
            }
        },
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    updated_leave_details = response_body.get("leave_details")
    assert updated_leave_details
    updated_leave_reason = updated_leave_details.get("reason")
    assert updated_leave_reason == "Serious Health Condition - Employee"
    updated_leave_reason_qualifier = updated_leave_details.get("reason_qualifier")
    assert updated_leave_reason_qualifier is None

    test_db_session.refresh(application)
    assert application.leave_reason_qualifier is None


def test_application_patch_add_leave_period(client, user, auth_token):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "has_continuous_leave_periods": True,
            "has_intermittent_leave_periods": False,
            "has_reduced_schedule_leave_periods": False,
            "leave_details": {"continuous_leave_periods": [{"start_date": "2021-01-01"}]},
        },
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")

    assert response_body.get("has_continuous_leave_periods") is True
    assert response_body.get("has_intermittent_leave_periods") is False
    assert response_body.get("has_reduced_schedule_leave_periods") is False

    updated_leave_details = response_body.get("leave_details")
    assert updated_leave_details

    updated_leave_periods = updated_leave_details.get("continuous_leave_periods")
    assert updated_leave_periods
    assert len(updated_leave_periods) == 1

    updated_leave_period = updated_leave_periods[0]
    assert updated_leave_period["leave_period_id"]
    assert updated_leave_period["start_date"] == "2021-01-01"


def test_application_patch_update_leave_period(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    leave_period = ContinuousLeavePeriod(
        start_date=date(2021, 1, 1), application_id=application.application_id
    )
    test_db_session.add(leave_period)
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "leave_details": {
                "continuous_leave_periods": [
                    {"leave_period_id": leave_period.leave_period_id, "start_date": "2021-01-03"}
                ]
            }
        },
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    updated_leave_details = response_body.get("leave_details")
    assert updated_leave_details

    updated_leave_periods = updated_leave_details.get("continuous_leave_periods")
    assert updated_leave_periods
    assert len(updated_leave_periods) == 1

    updated_leave_period = updated_leave_periods[0]
    assert updated_leave_period["leave_period_id"]
    assert updated_leave_period["start_date"] == "2021-01-03"


@pytest.mark.parametrize("new_leave_period_value", [([]), (None)])
def test_application_patch_delete_all_leave_periods(
    client, user, auth_token, test_db_session, new_leave_period_value
):
    application = ApplicationFactory.create(user=user)

    leave_periods = [
        ContinuousLeavePeriod(
            start_date=date(2021, 1, 1),
            end_date=date(2021, 1, 5),
            application_id=application.application_id,
        ),
        ContinuousLeavePeriod(
            start_date=date(2021, 1, 8),
            end_date=date(2021, 1, 10),
            application_id=application.application_id,
        ),
        ContinuousLeavePeriod(
            start_date=date(2021, 1, 12),
            end_date=date(2021, 1, 15),
            application_id=application.application_id,
        ),
    ]
    for leave_period in leave_periods:
        test_db_session.add(leave_period)
    test_db_session.commit()

    assert len(application.continuous_leave_periods) == len(leave_periods)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"leave_details": {"continuous_leave_periods": new_leave_period_value}},
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    updated_leave_details = response_body.get("leave_details")
    assert updated_leave_details

    updated_leave_periods = updated_leave_details.get("continuous_leave_periods")
    assert updated_leave_periods == []

    # Collect the IDs of these leave periods before refreshing the database connection.
    leave_period_ids = [leave_period.leave_period_id for leave_period in leave_periods]
    test_db_session.expire_all()
    for leave_period_id in leave_period_ids:
        assert test_db_session.query(ContinuousLeavePeriod).get(leave_period_id) is None


def test_application_patch_update_leave_period_belonging_to_other_application_blocked(
    client, user, auth_token, test_db_session
):
    application_1 = ApplicationFactory.create(user=user)
    application_2 = ApplicationFactory.create(user=user)

    leave_period = ContinuousLeavePeriod(
        start_date=date(2021, 6, 11), application_id=application_1.application_id
    )
    test_db_session.add(leave_period)
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application_2.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "leave_details": {
                "continuous_leave_periods": [
                    {"leave_period_id": leave_period.leave_period_id, "start_date": "2021-06-12"}
                ]
            }
        },
    )

    tests.api.validate_error_response(response, 403)

    # assert existing leave period has not changed
    # test_db_session.refresh(leave_period)
    assert leave_period.application_id == application_1.application_id
    assert leave_period.start_date == date(2021, 6, 11)

    # assert other application does not have the leave period
    response = client.get(
        "/v1/applications/{}".format(application_2.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    response_body = response.get_json().get("data")
    updated_leave_details = response_body.get("leave_details")
    assert updated_leave_details

    updated_leave_periods = updated_leave_details.get("continuous_leave_periods")
    assert len(updated_leave_periods) == 0


def test_application_patch_add_work_pattern(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "work_pattern": {
                "work_pattern_type": "Fixed",
                "work_pattern_days": [
                    {"day_of_week": "Wednesday", "minutes": 60 * 8},
                    {"day_of_week": "Monday", "minutes": 60 * 8},
                    {"day_of_week": "Friday", "minutes": 60 * 8},
                    {"day_of_week": "Thursday", "minutes": 60 * 8},
                    {"day_of_week": "Saturday", "minutes": 60 * 8},
                    {"day_of_week": "Tuesday", "minutes": 60 * 8},
                    {"day_of_week": "Sunday", "minutes": 60 * 8},
                ],
            }
        },
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    work_pattern = response_body.get("work_pattern")

    assert work_pattern.get("work_pattern_type") == "Fixed"
    assert len(work_pattern.get("work_pattern_days")) == 7
    work_pattern_days_of_week = [
        day.get("day_of_week") for day in work_pattern.get("work_pattern_days")
    ]
    assert work_pattern_days_of_week == [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
    ]


def test_application_patch_update_work_pattern(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    new_work_pattern = WorkPattern(
        work_pattern_days=[WorkPatternDay(day_of_week_id=i + 1) for i in range(7)],
        work_pattern_type_id=WorkPatternType.get_id("Fixed"),
    )
    application.work_pattern = new_work_pattern
    test_db_session.add(application)
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "work_pattern": {
                "work_pattern_type": "Fixed",
                "work_pattern_days": [
                    {"day_of_week": "Sunday", "minutes": 60 * 8},
                    {"day_of_week": "Monday", "minutes": 60 * 8},
                    {"day_of_week": "Tuesday", "minutes": 60 * 8},
                    {"day_of_week": "Wednesday", "minutes": 60 * 8},
                    {"day_of_week": "Thursday", "minutes": 60 * 8},
                    {"day_of_week": "Friday", "minutes": 60 * 8},
                    {"day_of_week": "Saturday", "minutes": 60 * 8},
                ],
            }
        },
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    work_pattern = response_body.get("work_pattern")

    assert work_pattern.get("work_pattern_type") == "Fixed"
    assert len(work_pattern.get("work_pattern_days")) == 7


def test_application_patch_remove_work_pattern_days(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    new_work_pattern = WorkPattern(
        work_pattern_type_id=1,
        work_pattern_days=[WorkPatternDay(day_of_week_id=i + 1) for i in range(7)],
    )
    application.work_pattern = new_work_pattern
    test_db_session.add(application)
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"work_pattern": {"work_pattern_type": "Variable", "work_pattern_days": None,}},
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    work_pattern = response_body.get("work_pattern")

    assert work_pattern.get("work_pattern_type") == "Variable"
    assert len(work_pattern.get("work_pattern_days")) == 0


def test_application_patch_invalid_work_pattern(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    base_work_pattern = {
        "work_pattern_type": "Fixed",
        "work_pattern_days": [
            {"day_of_week": "Sunday", "minutes": 60 * 8},
            {"day_of_week": "Monday", "minutes": 60 * 8},
            {"day_of_week": "Tuesday", "minutes": 60 * 8},
            {"day_of_week": "Wednesday", "minutes": 60 * 8},
            {"day_of_week": "Thursday", "minutes": 60 * 8},
            {"day_of_week": "Friday", "minutes": 60 * 8},
            {"day_of_week": "Saturday", "minutes": 60 * 8},
        ],
    }

    work_pattern_with_additional_days = copy.deepcopy(base_work_pattern)
    work_pattern_with_additional_days["work_pattern_days"].append(
        {"day_of_week": "Sunday", "minutes": 60 * 8}
    )

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"work_pattern": work_pattern_with_additional_days},
    )

    assert response.status_code == 400
    assert response.get_json().get("errors") == [
        {
            "field": "work_pattern.work_pattern_days",
            "message": "[{'day_of_week': 'Sunday', 'minutes': 480}, {'day_of_week': 'Monday', 'minutes': 480}, {'day_of_week': 'Tuesday', 'minutes': 480}, {'day_of_week': 'Wednesday', 'minutes': 480}, {'day_of_week': 'Thursday', 'minutes': 480}, {'day_of_week': 'Friday', 'minutes': 480}, {'day_of_week': 'Saturday', 'minutes': 480}, {'day_of_week': 'Sunday', 'minutes': 480}] is too long",
            "rule": 7,
            "type": "maxItems",
        }
    ]

    work_pattern_with_missing_days = {
        "work_pattern_type": "Fixed",
        "work_pattern_days": [
            {"day_of_week": "Sunday", "minutes": 60 * 8},
            {"day_of_week": "Monday", "minutes": 60 * 8},
            {"day_of_week": "Wednesday", "minutes": 60 * 8},
        ],
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"work_pattern": work_pattern_with_missing_days},
    )

    assert response.status_code == 400
    assert response.get_json().get("errors") == [
        {
            "field": "work_pattern.work_pattern_days",
            "message": "Provided work_pattern_days is missing Friday, Saturday, Thursday, Tuesday.",
            "rule": "no_missing_days",
            "type": "required",
        }
    ]


def test_application_patch_has_employer_benefits(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"has_employer_benefits": True,},
    )

    assert response.status_code == 200
    data = response.get_json().get("data")

    assert data.get("has_employer_benefits") is True


def test_application_patch_add_employer_benefits(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "employer_benefits": [
                {
                    "benefit_type": "Short-term disability insurance",
                    "benefit_start_date": "2021-01-10",
                    "benefit_end_date": "2021-01-20",
                    "benefit_amount_dollars": 400,
                    "benefit_amount_frequency": "Per Month",
                    "is_full_salary_continuous": True,
                }
            ]
        },
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    employer_benefits = response_body.get("employer_benefits")

    assert len(employer_benefits) == 1
    employer_benefit = employer_benefits[0]
    assert employer_benefit.get("employer_benefit_id") is not None
    assert employer_benefit.get("benefit_type") == "Short-term disability insurance"
    assert employer_benefit.get("benefit_start_date") == "2021-01-10"
    assert employer_benefit.get("benefit_end_date") == "2021-01-20"
    assert employer_benefit.get("benefit_amount_dollars") == 400
    assert employer_benefit.get("benefit_amount_frequency") == "Per Month"
    assert employer_benefit.get("is_full_salary_continuous") is True


def test_application_patch_add_empty_array_for_employer_benefits(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)

    benefits = [EmployerBenefitFactory.create(application_id=application.application_id)]
    application.employer_benefits = benefits

    test_db_session.add(application)
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"employer_benefits": []},
    )
    test_db_session.refresh(application)
    assert response.status_code == 200
    assert len(application.employer_benefits) == 0


def test_application_patch_add_empty_employer_benefits(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    benefits = [EmployerBenefitFactory.create(application_id=application.application_id)]
    application.employer_benefits = benefits

    test_db_session.add(application)
    test_db_session.commit()

    employer_benefit_id = application.employer_benefits[0].employer_benefit_id

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "employer_benefits": [
                {
                    "benefit_type": None,
                    "benefit_end_date": None,
                    "benefit_start_date": None,
                    "benefit_amount_dollars": None,
                    "benefit_amount_frequency": None,
                },
            ]
        },
    )
    test_db_session.refresh(application)

    assert response.status_code == 200

    warnings = response.get_json().get("warnings")
    assert len([x for x in warnings if x.get("field") == "employer_benefits[0].benefit_type"]) == 1
    assert len(application.employer_benefits) == 1
    assert application.employer_benefits[0].employer_benefit_id != str(employer_benefit_id)
    assert application.employer_benefits[0].employer_benefit_id is not None
    assert application.employer_benefits[0].benefit_type is None
    assert application.employer_benefits[0].benefit_start_date is None
    assert application.employer_benefits[0].benefit_end_date is None
    assert application.employer_benefits[0].benefit_amount_dollars is None
    assert application.employer_benefits[0].benefit_amount_frequency is None


def test_application_patch_replace_existing_employer_benefits(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)

    benefits = EmployerBenefitFactory.create_batch(
        size=2, application_id=application.application_id
    )
    application.employer_benefits = benefits
    test_db_session.add(application)
    test_db_session.commit()
    employer_benefit_id = application.employer_benefits[0].employer_benefit_id

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "employer_benefits": [
                {
                    "employer_benefit_id": employer_benefit_id,
                    "benefit_type": "Short-term disability insurance",
                    "benefit_end_date": "2021-01-20",
                    "benefit_start_date": "2021-01-10",
                    "benefit_amount_dollars": 400,
                    "benefit_amount_frequency": "Per Month",
                },
            ]
        },
    )

    test_db_session.refresh(application)

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    employer_benefits = response_body.get("employer_benefits")

    assert len(employer_benefits) == 1
    employer_benefit = employer_benefits[0]
    assert employer_benefit.get("employer_benefit_id") != str(employer_benefit_id)
    assert application.employer_benefits[0].employer_benefit_id != str(employer_benefit_id)
    assert employer_benefit.get("benefit_type") == "Short-term disability insurance"
    assert employer_benefit.get("benefit_start_date") == "2021-01-10"
    assert employer_benefit.get("benefit_end_date") == "2021-01-20"
    assert employer_benefit.get("benefit_amount_dollars") == 400
    assert employer_benefit.get("benefit_amount_frequency") == "Per Month"


def test_application_patch_employer_benefit_exceed_limit(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    limit = 6

    benefits = EmployerBenefitFactory.create_batch(
        size=5, application_id=application.application_id
    )
    application.employer_benefits = benefits
    test_db_session.add(application)
    test_db_session.commit()

    existing_benefits = application.employer_benefits

    new_benefits = [
        {
            "benefit_type": "Short-term disability insurance",
            "benefit_end_date": "2021-01-20",
            "benefit_start_date": "2021-01-10",
            "benefit_amount_dollars": 400,
            "benefit_amount_frequency": "Per Month",
        }
        for i in range(limit + 1)
    ]

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"employer_benefits": new_benefits},
    )

    assert response.status_code == 400
    test_db_session.refresh(application)
    assert application.employer_benefits == existing_benefits


def test_application_patch_has_other_incomes(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"has_other_incomes": True,},
    )

    assert response.status_code == 200
    data = response.get_json().get("data")

    assert data.get("has_other_incomes") is True


def test_application_patch_add_other_incomes(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "other_incomes": [
                {
                    "income_type": "Unemployment Insurance",
                    "income_end_date": "2021-01-20",
                    "income_start_date": "2021-01-10",
                    "income_amount_dollars": 800,
                    "income_amount_frequency": "Per Month",
                },
            ]
        },
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    other_incomes = response_body.get("other_incomes")

    assert len(other_incomes) == 1
    other_income = other_incomes[0]
    assert other_income.get("income_type") == "Unemployment Insurance"
    assert other_income.get("income_start_date") == "2021-01-10"
    assert other_income.get("income_end_date") == "2021-01-20"
    assert other_income.get("income_amount_dollars") == 800
    assert other_income.get("income_amount_frequency") == "Per Month"


def test_application_patch_add_empty_array_for_other_incomes(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)

    incomes = [OtherIncomeFactory.create(application_id=application.application_id,)]
    application.other_incomes = incomes

    test_db_session.add(application)
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"other_incomes": []},
    )
    test_db_session.refresh(application)

    assert response.status_code == 200
    assert len(application.other_incomes) == 0


def test_application_patch_add_empty_other_income(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    incomes = [OtherIncomeFactory.create(application_id=application.application_id,)]
    application.other_incomes = incomes

    test_db_session.add(application)
    test_db_session.commit()
    other_income_id = application.other_incomes[0].other_income_id

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "other_incomes": [
                {
                    "income_type": None,
                    "income_end_date": None,
                    "income_start_date": None,
                    "income_amount_dollars": None,
                    "income_amount_frequency": None,
                },
            ]
        },
    )

    test_db_session.refresh(application)

    assert response.status_code == 200
    warnings = response.get_json().get("warnings")
    assert len([x for x in warnings if x.get("field") == "other_incomes[0].income_type"]) == 1
    assert len(application.other_incomes) == 1
    assert application.other_incomes[0].other_income_id != str(other_income_id)
    assert application.other_incomes[0].other_income_id is not None
    assert application.other_incomes[0].income_type is None
    assert application.other_incomes[0].income_start_date is None
    assert application.other_incomes[0].income_end_date is None
    assert application.other_incomes[0].income_amount_dollars is None
    assert application.other_incomes[0].income_amount_frequency is None


def test_application_patch_replace_existing_other_incomes(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)

    incomes = OtherIncomeFactory.create_batch(size=2, application_id=application.application_id,)

    application.other_incomes = incomes
    test_db_session.add(application)
    test_db_session.commit()
    other_income_id = application.other_incomes[0].other_income_id

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "other_incomes": [
                {
                    "other_income_id": other_income_id,
                    "income_type": "Workers Compensation",
                    "income_end_date": "2021-01-20",
                    "income_start_date": "2021-01-10",
                    "income_amount_dollars": 400,
                    "income_amount_frequency": "Per Month",
                },
            ]
        },
    )

    test_db_session.refresh(application)
    assert response.status_code == 200

    response_body = response.get_json().get("data")
    other_incomes = response_body.get("other_incomes")

    assert len(other_incomes) == 1
    other_income = other_incomes[0]
    assert other_income.get("other_income_id") != str(other_income_id)
    assert application.other_incomes[0].other_income_id != str(other_income_id)
    assert other_income.get("income_type") == "Workers Compensation"
    assert other_income.get("income_start_date") == "2021-01-10"
    assert other_income.get("income_end_date") == "2021-01-20"
    assert other_income.get("income_amount_dollars") == 400
    assert other_income.get("income_amount_frequency") == "Per Month"


def test_application_patch_other_income_exceed_limit(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    limit = 6

    incomes = OtherIncomeFactory.create_batch(size=5, application_id=application.application_id,)
    application.other_incomes = incomes
    test_db_session.add(application)
    test_db_session.commit()

    existing_incomes = application.other_incomes

    new_incomes = [
        {
            "income_type": "Workers Compensation",
            "income_end_date": "2021-01-20",
            "income_start_date": "2021-01-10",
            "income_amount_dollars": 400,
            "income_amount_frequency": "Per Month",
        }
        for i in range(limit + 1)
    ]

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"other_incomes": new_incomes},
    )

    assert response.status_code == 400
    test_db_session.refresh(application)
    assert application.other_incomes == existing_incomes


def test_application_patch_concurrent_leave(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "has_concurrent_leave": True,
            "concurrent_leave": {
                "is_for_current_employer": True,
                "leave_start_date": "2021-06-01",
                "leave_end_date": "2021-07-01",
            },
        },
    )

    assert response.status_code == 200

    data = response.get_json().get("data")

    assert data["concurrent_leave"]["is_for_current_employer"] is True
    assert data["concurrent_leave"]["leave_start_date"] == "2021-06-01"
    assert data["concurrent_leave"]["leave_end_date"] == "2021-07-01"


def test_application_delete_concurrent_leave(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    ConcurrentLeaveFactory.create(application_id=application.application_id)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"has_concurrent_leave": False, "concurrent_leave": None},
    )

    assert response.status_code == 200

    data = response.get_json().get("data")

    assert getattr(data, "concurrent_leave", None) is None


def test_application_patch_concurrent_leave_replaces_existing_leave(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)
    ConcurrentLeaveFactory.create(
        application_id=application.application_id,
        leave_start_date="2021-01-01",
        leave_end_date="2021-03-01",
    )

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "has_concurrent_leave": False,
            "concurrent_leave": {
                "is_for_current_employer": True,
                "leave_start_date": "2021-06-01",
                "leave_end_date": "2021-07-01",
            },
        },
    )

    assert response.status_code == 200

    data = response.get_json().get("data")

    assert data["concurrent_leave"]["is_for_current_employer"] is True
    assert data["concurrent_leave"]["leave_start_date"] == "2021-06-01"
    assert data["concurrent_leave"]["leave_end_date"] == "2021-07-01"

    assert (
        test_db_session.query(ConcurrentLeave)
        .filter(ConcurrentLeave.application_id == application.application_id)
        .count()
        == 1
    )


def test_application_patch_concurrent_leave_is_optional(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"has_concurrent_leave": False,},
    )

    assert response.status_code == 200
    warnings = response.get_json().get("warnings")

    assert {
        "field": "concurrent_leave",
        "message": "when has_concurrent_leave is true, concurrent_leave must be present",
        "type": "required",
        "rule": "conditional",
    } not in warnings


def test_application_patch_concurrent_leave_validate_is_not_present(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"has_concurrent_leave": True,},
    )

    assert response.status_code == 200
    warnings = response.get_json().get("warnings")

    assert {
        "field": "concurrent_leave",
        "message": "when has_concurrent_leave is true, concurrent_leave must be present",
        "type": "required",
        "rule": "conditional",
    } in warnings


def test_application_patch_concurrent_leave_validate_is_present(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)
    concurrent_leave = ConcurrentLeaveFactory(application_id=application.application_id)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"has_concurrent_leave": True,},
    )

    assert response.status_code == 200
    data = response.get_json().get("data")
    warnings = response.get_json().get("warnings")

    assert {
        "field": "concurrent_leave",
        "message": "when has_concurrent_leave is true, concurrent_leave must be present",
        "type": "required",
        "rule": "conditional",
    } not in warnings

    data_concurrent_leave = data.get("concurrent_leave")
    assert data_concurrent_leave is not None
    assert (
        data_concurrent_leave["is_for_current_employer"] == concurrent_leave.is_for_current_employer
    )
    assert data_concurrent_leave["leave_start_date"] == concurrent_leave.leave_start_date.__str__()
    assert data_concurrent_leave["leave_end_date"] == concurrent_leave.leave_end_date.__str__()


def test_application_patch_concurrent_leave_validate_is_present_but_flag_is_false(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)
    ConcurrentLeaveFactory(application_id=application.application_id)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"has_concurrent_leave": False,},
    )

    assert response.status_code == 200
    data = response.get_json().get("data")
    assert data.get("has_concurrent_leave") is False
    data_concurrent_leave = data.get("concurrent_leave")
    assert data_concurrent_leave is not None

    warnings = response.get_json().get("warnings")

    assert {
        "field": "concurrent_leave",
        "message": "when has_concurrent_leave is false, concurrent_leave must be null",
        "type": "required",
        "rule": "conditional",
    } in warnings


def test_application_patch_has_previous_leaves(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"has_previous_leaves_other_reason": True, "has_previous_leaves_same_reason": True,},
    )

    assert response.status_code == 200
    data = response.get_json().get("data")

    assert data.get("has_previous_leaves_other_reason") is True
    assert data.get("has_previous_leaves_same_reason") is True


def test_application_patch_add_previous_leaves(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "previous_leaves_other_reason": [
                {
                    "is_for_current_employer": True,
                    "leave_start_date": "2021-01-01",
                    "leave_end_date": "2021-05-01",
                    "leave_reason": "Pregnancy",
                    "worked_per_week_minutes": 20,
                    "leave_minutes": 10,
                }
            ],
            "previous_leaves_same_reason": [
                {
                    "is_for_current_employer": True,
                    "leave_start_date": "2021-01-01",
                    "leave_end_date": "2021-05-01",
                    "worked_per_week_minutes": 20,
                    "leave_minutes": 10,
                }
            ],
        },
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    previous_leaves_other_reason = response_body.get("previous_leaves_other_reason")
    previous_leaves_same_reason = response_body.get("previous_leaves_same_reason")

    assert len(previous_leaves_other_reason) == 1
    assert len(previous_leaves_same_reason) == 1
    assert previous_leaves_other_reason[0].get("previous_leave_id") != previous_leaves_same_reason[
        0
    ].get("previous_leave_id")

    for previous_leave in [
        previous_leaves_other_reason[0],
        previous_leaves_same_reason[0],
    ]:
        assert previous_leave.get("is_for_current_employer") is True
        assert previous_leave.get("leave_start_date") == "2021-01-01"
        assert previous_leave.get("leave_end_date") == "2021-05-01"
        assert previous_leave.get("worked_per_week_minutes") == 20
        assert previous_leave.get("leave_minutes") == 10

    assert previous_leaves_other_reason[0].get("leave_reason") == "Pregnancy"
    assert previous_leaves_same_reason[0].get("leave_reason") is None


def test_application_patch_add_empty_array_for_previous_leaves(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)

    application.previous_leaves_other_reason = [
        PreviousLeaveOtherReasonFactory.create(application_id=application.application_id,)
    ]
    application.previous_leaves_same_reason = [
        PreviousLeaveSameReasonFactory.create(application_id=application.application_id,)
    ]

    test_db_session.add(application)
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"previous_leaves_other_reason": [], "previous_leaves_same_reason": [],},
    )
    test_db_session.refresh(application)

    assert response.status_code == 200
    assert len(application.previous_leaves_other_reason) == 0
    assert len(application.previous_leaves_same_reason) == 0


def test_application_patch_add_empty_previous_leaves(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)

    application.previous_leaves_other_reason = [
        PreviousLeaveOtherReasonFactory.create(application_id=application.application_id,)
    ]
    application.previous_leaves_same_reason = [
        PreviousLeaveSameReasonFactory.create(application_id=application.application_id,)
    ]
    test_db_session.add(application)
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "previous_leaves_other_reason": [
                {
                    "is_for_current_employer": None,
                    "leave_end_date": None,
                    "leave_start_date": None,
                    "leave_reason": None,
                    "worked_per_week_minutes": None,
                    "leave_minutes": None,
                },
            ],
            "previous_leaves_same_reason": [
                {
                    "is_for_current_employer": None,
                    "leave_end_date": None,
                    "leave_start_date": None,
                    "leave_reason": None,
                    "worked_per_week_minutes": None,
                    "leave_minutes": None,
                },
            ],
        },
    )

    test_db_session.refresh(application)

    assert response.status_code == 200

    for leaves in [
        application.previous_leaves_other_reason,
        application.previous_leaves_same_reason,
    ]:
        assert leaves[0].previous_leave_id is not None
        assert leaves[0].is_for_current_employer is None
        assert leaves[0].leave_start_date is None
        assert leaves[0].leave_reason is None
        assert leaves[0].worked_per_week_minutes is None
        assert leaves[0].leave_minutes is None


def test_application_patch_replace_existing_previous_leave_same_reason(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)

    application.previous_leaves_other_reason = PreviousLeaveOtherReasonFactory.create_batch(
        size=2, application_id=application.application_id,
    )
    application.previous_leaves_same_reason = PreviousLeaveSameReasonFactory.create_batch(
        size=2, application_id=application.application_id,
    )
    test_db_session.add(application)
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "previous_leaves_same_reason": [
                {
                    "is_for_current_employer": False,
                    "leave_start_date": "2021-02-01",
                    "leave_end_date": "2021-06-01",
                    "worked_per_week_minutes": 20,
                    "leave_minutes": 10,
                }
            ],
        },
    )

    test_db_session.refresh(application)

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    previous_leaves_other_reason = response_body.get("previous_leaves_other_reason")
    previous_leaves_same_reason = response_body.get("previous_leaves_same_reason")

    assert len(previous_leaves_other_reason) == 2
    assert len(previous_leaves_same_reason) == 1

    previous_leave = previous_leaves_same_reason[0]
    assert previous_leave.get("is_for_current_employer") is False
    assert previous_leave.get("leave_start_date") == "2021-02-01"
    assert previous_leave.get("leave_end_date") == "2021-06-01"
    assert previous_leave.get("leave_reason") is None
    assert previous_leave.get("worked_per_week_minutes") == 20
    assert previous_leave.get("leave_minutes") == 10


def test_application_patch_replace_existing_previous_leave_other_reason(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)

    application.previous_leaves_other_reason = PreviousLeaveOtherReasonFactory.create_batch(
        size=2, application_id=application.application_id,
    )
    application.previous_leaves_same_reason = PreviousLeaveSameReasonFactory.create_batch(
        size=2, application_id=application.application_id,
    )
    test_db_session.add(application)
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "previous_leaves_other_reason": [
                {
                    "is_for_current_employer": False,
                    "leave_start_date": "2021-02-01",
                    "leave_end_date": "2021-06-01",
                    "leave_reason": "Pregnancy",
                    "worked_per_week_minutes": 20,
                    "leave_minutes": 10,
                }
            ],
        },
    )

    test_db_session.refresh(application)

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    previous_leaves_other_reason = response_body.get("previous_leaves_other_reason")
    previous_leaves_same_reason = response_body.get("previous_leaves_same_reason")

    assert len(previous_leaves_other_reason) == 1
    assert len(previous_leaves_same_reason) == 2

    previous_leave = previous_leaves_other_reason[0]
    assert previous_leave.get("is_for_current_employer") is False
    assert previous_leave.get("leave_start_date") == "2021-02-01"
    assert previous_leave.get("leave_end_date") == "2021-06-01"
    assert previous_leave.get("leave_reason") == "Pregnancy"
    assert previous_leave.get("worked_per_week_minutes") == 20
    assert previous_leave.get("leave_minutes") == 10


def test_application_patch_delete_existing_previous_leave_same_reason(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)

    application.previous_leaves_other_reason = PreviousLeaveOtherReasonFactory.create_batch(
        size=2, application_id=application.application_id,
    )
    application.previous_leaves_same_reason = PreviousLeaveSameReasonFactory.create_batch(
        size=2, application_id=application.application_id,
    )
    test_db_session.add(application)
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"previous_leaves_same_reason": None,},
    )

    test_db_session.refresh(application)

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    previous_leaves_other_reason = response_body.get("previous_leaves_other_reason")
    previous_leaves_same_reason = response_body.get("previous_leaves_same_reason")

    assert len(previous_leaves_other_reason) == 2
    assert len(previous_leaves_same_reason) == 0


def test_application_patch_delete_existing_previous_leave_other_reason(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)

    application.previous_leaves_other_reason = PreviousLeaveOtherReasonFactory.create_batch(
        size=2, application_id=application.application_id,
    )
    application.previous_leaves_same_reason = PreviousLeaveSameReasonFactory.create_batch(
        size=2, application_id=application.application_id,
    )
    test_db_session.add(application)
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"previous_leaves_other_reason": None,},
    )

    test_db_session.refresh(application)

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    previous_leaves_other_reason = response_body.get("previous_leaves_other_reason")
    previous_leaves_same_reason = response_body.get("previous_leaves_same_reason")

    assert len(previous_leaves_other_reason) == 0
    assert len(previous_leaves_same_reason) == 2


def test_application_patch_previous_leave_exceed_limit(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    limit = 6

    application.previous_leaves_other_reason = PreviousLeaveOtherReasonFactory.create_batch(
        size=2, application_id=application.application_id,
    )
    application.previous_leaves_same_reason = PreviousLeaveSameReasonFactory.create_batch(
        size=2, application_id=application.application_id,
    )

    test_db_session.add(application)
    test_db_session.commit()

    existing_leaves_other_reason = application.previous_leaves_other_reason
    existing_leaves_same_reason = application.previous_leaves_same_reason

    new_leaves = [
        {
            "is_for_current_employer": False,
            "leave_start_date": "2021-02-01",
            "leave_end_date": "2021-06-01",
            "leave_reason": "Pregnancy",
            "worked_per_week_minutes": 20,
            "leave_minutes": 10,
        }
        for i in range(limit + 1)
    ]

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "previous_leaves_other_reason": new_leaves,
            "previous_leaves_same_reason": new_leaves,
        },
    )

    assert response.status_code == 400
    test_db_session.refresh(application)

    assert application.previous_leaves_other_reason == existing_leaves_other_reason
    assert application.previous_leaves_same_reason == existing_leaves_same_reason


def test_application_patch_null_date_of_birth(client, user, auth_token):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"date_of_birth": None},
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    dob = response_body.get("date_of_birth")
    assert dob is None


def test_application_patch_date_of_birth_after_1900_over_14(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)

    now = datetime.now()
    test_date = now - relativedelta(years=20)
    test_date_str = test_date.strftime("%Y-%m-%d")

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"date_of_birth": test_date_str},
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    dob = response_body.get("date_of_birth")
    assert dob == f"****{test_date_str[4:]}"

    test_db_session.refresh(application)
    assert application.date_of_birth.isoformat() == test_date_str


def test_application_patch_date_of_birth_under_14(client, user, auth_token):
    application = ApplicationFactory.create(user=user)

    now = datetime.now()
    test_date = now - relativedelta(years=14) + relativedelta(days=1)
    test_date_string = test_date.strftime("%Y-%m-%d")

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"date_of_birth": test_date_string},
    )

    assert response.status_code == 400

    response_body = response.get_json()
    errors = response_body.get("errors")
    assert len(errors) == 1

    error = errors[0]
    field = error.get("field")
    message = error.get("message")
    rule = error.get("rule")
    error_type = error.get("type")

    assert field == "date_of_birth"
    assert message == "The person taking leave must be at least 14 years old"
    assert rule == "older_than_14"
    assert error_type == "invalid_age"


def test_application_patch_date_of_birth_before_1850(client, user, auth_token):
    application = ApplicationFactory.create(user=user)

    now = datetime.now()
    test_date = now.replace(year=1849)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"date_of_birth": test_date.strftime("%Y-%m-%d")},
    )

    assert response.status_code == 400

    response_body = response.get_json()
    errors = response_body.get("errors")
    assert len(errors) == 1

    error = errors[0]
    field = error.get("field")
    message = error.get("message")
    rule = error.get("rule")
    error_type = error.get("type")

    assert field == "date_of_birth"
    assert message == "Date of birth must be within the past 150 years"
    assert rule == "date_of_birth_within_past_150_years"
    assert error_type == "invalid_year_range"


@freeze_time("2020-01-01")
def test_application_patch_date_of_birth_in_future(client, user, auth_token):
    application = ApplicationFactory.create(user=user)
    date_of_birth = "2022-01-01"

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"date_of_birth": date_of_birth},
    )

    assert response.status_code == 400

    response_body = response.get_json()
    errors = response_body.get("errors")
    assert len(errors) == 1

    error = errors[0]
    field = error.get("field")
    message = error.get("message")
    rule = error.get("rule")
    error_type = error.get("type")

    assert field == "date_of_birth"
    assert message == "The person taking leave must be at least 14 years old"
    assert rule == "older_than_14"
    assert error_type == "invalid_age"


def test_application_patch_date_of_birth_invalid(client, user, auth_token):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "date_of_birth": "1970-13-42",
            "leave_details": {
                "employer_notification_date": "970-06-01",
                "reduced_schedule_leave_periods": [{"end_date": ""}],
            },
        },
    )

    tests.api.validate_error_response(
        response,
        400,
        errors=[
            {
                "field": "date_of_birth",
                "message": "'1970-13-42' is not a 'maskable_date'",
                "rule": "maskable_date",
                "type": "format",
            },
            {
                "field": "leave_details.reduced_schedule_leave_periods.0.end_date",
                "message": "'' is not a 'date'",
                "rule": "date",
                "type": "format",
            },
            {
                "field": "leave_details.employer_notification_date",
                "message": "'970-06-01' is not a 'date'",
                "rule": "date",
                "type": "format",
            },
        ],
    )


def test_application_patch_minimum_payload(client, user, auth_token):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={},
    )

    assert response.status_code == 200

    response_body = response.get_json().get("data")
    data = response_body
    assert application.nickname == data.get("application_nickname")


def test_application_patch_null_values(client, user, auth_token):
    application = ApplicationFactory.create(user=user)

    null_request_body = {
        "application_id": application.application_id,
        "application_nickname": None,
        "tax_identifier": None,
        "employer_fein": None,
        "hours_worked_per_week": None,
        "first_name": None,
        "last_name": None,
        "leave_details": {
            "continuous_leave_periods": [
                {
                    "end_date": None,
                    "end_date_full_day": None,
                    "end_date_off_hours": None,
                    "end_date_off_minutes": None,
                    "expected_return_to_work_date": None,
                    "last_day_worked": None,
                    "start_date": None,
                    "start_date_full_day": None,
                    "start_date_off_hours": None,
                    "start_date_off_minutes": None,
                    "status": None,
                }
            ],
            "child_birth_date": None,
            "child_placement_date": None,
            "employer_notification_date": None,
            "employer_notification_method": None,
            "employer_notified": None,
            "intermittent_leave_periods": [
                {
                    "duration": None,
                    "duration_basis": None,
                    "end_date": None,
                    "frequency": None,
                    "frequency_interval": None,
                    "frequency_interval_basis": None,
                    "start_date": None,
                }
            ],
            "reason": None,
            "reason_qualifier": None,
            "reduced_schedule_leave_periods": [
                {
                    "end_date": None,
                    "friday_off_minutes": None,
                    "monday_off_minutes": None,
                    "saturday_off_minutes": None,
                    "start_date": None,
                    "status": None,
                    "sunday_off_minutes": None,
                    "thursday_off_minutes": None,
                    "tuesday_off_minutes": None,
                    "wednesday_off_minutes": None,
                }
            ],
            "relationship_qualifier": None,
            "relationship_to_caregiver": None,
        },
        "occupation": None,
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=null_request_body,
    )

    assert response.get_json().get("warnings")
    assert response.status_code == 200


def test_application_patch_invalid_values(client, user, auth_token):
    # Assert that API returns a 400 error when the request body
    # doesn't conform to the OpenAPI spec
    application = ApplicationFactory.create(user=user)

    update_request_body = {
        # Leave periods should be an array, not an object
        "leave_details": {"reduced_schedule_leave_periods": {}},
        # mass_id should conform to the pattern (e.g 123456789),
        "mass_id": "1234567890000",
        "residential_address": {
            # zip should conform to the pattern (e.g 12345-1234),
            "zip": "123456"
        },
        # tax_identifier should conform to the pattern (e.g 123-45-6789),
        "tax_identifier": "123-45-67890000",
        "phone": {
            # phone number should conform to the pattern (e.g. 555-123-4567)
            "phone_number": "(555) 123-4567",
            "phone_type": "Cell",
            "int_code": "1",
        },
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    tests.api.validate_error_response(
        response,
        400,
        message="Request Validation Error",
        errors=[
            {
                "field": "tax_identifier",
                "message": "'123-45-67890000' does not match '^[\\\\d|\\\\*]{3}-[\\\\d|\\\\*]{2}-\\\\d{4}$'",
                "rule": "^[\\d|\\*]{3}-[\\d|\\*]{2}-\\d{4}$",
                "type": "pattern",
            },
            {
                "field": "residential_address.zip",
                "message": "'123456' does not match '^[0-9]{5}((?:-[0-9]{4})?|(?:-\\\\*{4})?)$'",
                "rule": "^[0-9]{5}((?:-[0-9]{4})?|(?:-\\*{4})?)$",
                "type": "pattern",
            },
            {
                "field": "mass_id",
                "message": "'1234567890000' does not match '^(\\\\d{9}|S(\\\\d{8}|A\\\\d{7})|(\\\\*{9}))$'",
                "rule": "^(\\d{9}|S(\\d{8}|A\\d{7})|(\\*{9}))$",
                "type": "pattern",
            },
            {
                "field": "leave_details.reduced_schedule_leave_periods",
                "message": "{} is not of type 'array'",
                "rule": "array",
                "type": "type",
            },
            {
                "field": "phone.phone_number",
                "message": "'(555) 123-4567' does not match '^([0-9]|\\\\*){3}\\\\-([0-9]|\\\\*){3}\\\\-[0-9]{4}$'",
                "rule": "^([0-9]|\\*){3}\\-([0-9]|\\*){3}\\-[0-9]{4}$",
                "type": "pattern",
            },
        ],
    )


@pytest.mark.parametrize("state_string", ("ZZ", "New York"))
def test_application_patch_state_invalid(client, user, auth_token, state_string):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"mailing_address": {"state": state_string}},
    )

    tests.api.validate_error_response(
        response,
        400,
        errors=[
            {
                "field": "mailing_address.state",
                "message": f"'{state_string}' is not a valid state",
                "type": "invalid",
            },
        ],
    )


def test_application_patch_state_valid(client, user, auth_token):
    application = ApplicationFactory.create(user=user)

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"mailing_address": {"state": "NY"}},
    )

    assert response.json["data"]["mailing_address"]["state"] == "NY"
    assert response.status_code == 200


def test_application_patch_fein_not_found(client, user, auth_token):
    # Assert that API returns a validation warning when the request
    # includes an EIN that doesn't match an Employer record
    application = ApplicationFactory.create(user=user)

    update_request_body = {
        "employer_fein": "99-9999999",
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    response_body = response.get_json()
    warnings = response_body.get("warnings")

    assert {
        "field": "employer_fein",
        "message": "Confirm that you have the correct EIN, and that the Employer is contributing to Paid Family and Medical Leave.",
        "type": "require_contributing_employer",
    } in warnings


def test_application_patch_keys_not_in_body_retain_existing_value(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)

    # establish some existing value
    application.first_name = "Foo"
    test_db_session.commit()

    response = client.get(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    response_body = response.get_json().get("data")

    assert response_body.get("first_name") == "Foo"

    # update some other field
    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"last_name": "Bar"},
    )

    assert response.status_code == 200

    # ensure the existing field still has it's existing value
    test_db_session.refresh(application)
    assert application.first_name == "Foo"

    # for extra measure
    response_body = response.get_json().get("data")
    assert response_body.get("first_name") == "Foo"


def test_application_patch_key_set_to_null_does_null_field(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)

    # establish some existing value
    application.first_name = "Foo"
    test_db_session.commit()

    response = client.get(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    response_body = response.get_json().get("data")
    assert response_body.get("first_name") == "Foo"

    # null the field
    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={"first_name": None},
    )

    assert response.status_code == 200

    # ensure it's null in the db
    test_db_session.refresh(application)
    assert application.first_name is None

    # for extra measure
    response_body = response.get_json().get("data")
    assert response_body.get("first_name") is None


def test_application_patch_failure_after_absence_case_creation(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)
    claim = ClaimFactory.create(
        fineos_notification_id="NTN-1989", fineos_absence_id="NTN-1989-ABS-01"
    )

    # Attach absence case information application so it appears as if this application has already been submitted.
    application.claim = claim
    application.submitted_time = datetime_util.utcnow()
    test_db_session.commit()

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json={},
    )
    message = "Application {} could not be updated. Application already submitted on {}".format(
        application.application_id, datetime_util.utcnow().strftime("%x")
    )
    tests.api.validate_error_response(
        response,
        403,
        message=message,
        errors=[{"type": "exists", "field": "claim", "message": message}],
    )


def test_application_post_submit_app(client, user, auth_token, test_db_session):
    factory.random.reseed_random(1)
    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user, employer_fein=employer.employer_fein, tax_identifier=employee.tax_identifier
    )
    WagesAndContributionsFactory.create(employer=employer, employee=employee)

    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(start_date=date(2021, 1, 1))
    ]
    application.date_of_birth = date(1997, 6, 6)
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.hours_worked_per_week = 70
    application.has_continuous_leave_periods = True
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()

    assert not application.submitted_time

    test_db_session.commit()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )
    response_body = response.get_json()

    assert response.status_code == 201
    assert not response_body.get("errors")
    assert not response_body.get("warnings")
    # Simplified check to confirm Application was included in response:
    assert response_body.get("data").get("application_id") == str(application.application_id)
    assert response_body.get("data").get("fineos_absence_id") == "NTN-259-ABS-01"
    assert response_body.get("data").get("status") == ApplicationStatus.Submitted.value


def create_mock_client(err: FINEOSClientError):
    class MockFINEOSTestClient(massgov.pfml.fineos.mock_client.MockFINEOSClient):
        def register_api_user(
            self, employee_registration: massgov.pfml.fineos.models.EmployeeRegistration
        ) -> None:
            raise err

    def inner(config: Optional[FINEOSClientConfig] = None) -> AbstractFINEOSClient:
        return MockFINEOSTestClient()

    return inner


@pytest.mark.parametrize(
    "expected_status,issue_type,err",
    [
        (
            400,
            IssueType.fineos_case_creation_issues,
            FINEOSEntityNotFound(
                "<ErrorDetails><faultcode>com.fineos.common.portalinfrastructure.exceptions.GenericUncheckedException</faultcode><faultstring>The employee does not have an occupation linked.</faultstring><detail></detail></ErrorDetails>"
            ),
        ),
        (
            500,
            None,
            FINEOSFatalResponseError(
                method_name="test_name",
                message="<ErrorDetails><faultcode>com.fineos.common.exceptions.WSException</faultcode><faultstring>More than One Employee Details Found for the input Search Criteria.</faultstring><detail></detail></ErrorDetails>",
            ),
        ),
        (
            503,
            IssueType.fineos_case_error,
            FINEOSFatalUnavailable(response_status=504, method_name="test_name"),
        ),
    ],
)
def test_application_post_submit_fineos_register_api_errors(
    client, user, auth_token, test_db_session, monkeypatch, err, expected_status, issue_type
):
    monkeypatch.setattr(massgov.pfml.fineos, "create_client", create_mock_client(err))

    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user, employer_fein=employer.employer_fein, tax_identifier=employee.tax_identifier
    )
    WagesAndContributionsFactory.create(employer=employer, employee=employee)

    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(start_date=date(2021, 1, 1))
    ]
    application.date_of_birth = date(1997, 6, 6)
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.hours_worked_per_week = 70
    application.has_continuous_leave_periods = True
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    test_db_session.commit()

    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == expected_status

    response_body = response.get_json()
    expected_message = f"Application {str(application.application_id)} could not be submitted"

    if expected_status == 503:
        expected_message += ", try again later"

    assert response_body.get("message"), expected_message

    fineos_issues = response_body.get("errors")
    assert not response_body.get("warnings")

    num_issues = len(list(filter(lambda i: i["type"] == issue_type, fineos_issues)))

    if issue_type is None:
        assert num_issues == 0
    else:
        assert num_issues > 0
        # Simplified check to confirm Application was included in response:
        assert response_body.get("data").get("application_id") == str(application.application_id)
        assert not response_body.get("data").get("fineos_absence_id")
        assert response_body.get("data").get("status") == ApplicationStatus.Started.value


def test_application_post_submit_app_already_submitted(client, user, auth_token, test_db_session):
    # This test aims to test the scenario where the application was successfully sent to fineos,
    # but failed when trying to complete the intake. This would mean we have the fineos_absence_id,
    # but it isn't currently in submitted status. This verifies that it only calls methods in complete_intake.
    factory.random.reseed_random(1)
    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user, employer_fein=employer.employer_fein, tax_identifier=employee.tax_identifier
    )
    WagesAndContributionsFactory.create(employer=employer, employee=employee)

    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(start_date=date(2021, 1, 1))
    ]
    claim = ClaimFactory.create(
        fineos_notification_id="NTN-1989", fineos_absence_id="NTN-1989-ABS-01"
    )

    application.date_of_birth = date(1997, 6, 6)
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.hours_worked_per_week = 70
    application.has_continuous_leave_periods = True
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()

    # Add fineos_absence_id so it behaves like it was submitted but failed to complete intake
    application.claim = claim

    assert not application.submitted_time

    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )
    response_body = response.get_json()

    assert response.status_code == 201
    assert not response_body.get("errors")
    assert not response_body.get("warnings")
    # Just verify that it was marked as submitted
    assert response_body.get("data").get("status") == ApplicationStatus.Submitted.value

    capture = massgov.pfml.fineos.mock_client.get_capture()
    # This is generated randomly and changes each time.
    fineos_user_id = capture[2][1]
    # Capture contains a find_employer call and the complete_intake call
    assert capture == [
        ("find_employer", None, {"employer_fein": application.employer_fein}),
        (
            "register_api_user",
            None,
            {
                "employee_registration": massgov.pfml.fineos.models.EmployeeRegistration(
                    user_id=fineos_user_id,
                    customer_number=None,
                    employer_id=f"{application.employer_fein}1000",
                    date_of_birth=date(1753, 1, 1),
                    email=None,
                    first_name=None,
                    last_name=None,
                    national_insurance_no=application.tax_identifier.tax_identifier,
                )
            },
        ),
        ("complete_intake", fineos_user_id, {"notification_case_id": "NTN-1989"},),
    ]


def test_application_post_submit_caring_leave_app_before_july(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)
    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(
            start_date=date(2021, 6, 30), end_date=date(2022, 1, 30)
        )
    ]
    application.has_continuous_leave_periods = True
    application.leave_reason_id = LeaveReason.CARE_FOR_A_FAMILY_MEMBER.leave_reason_id

    test_db_session.commit()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )
    response_body = response.get_json()

    assert response.status_code == 400

    errors = response_body.get("errors")

    assert {
        "message": "Caring leave start_date cannot be before 2021-07-01",
        "rule": "disallow_caring_leave_before_july",
        "type": "",
    } in errors


@freeze_time("2020-01-01")
def test_application_post_submit_app_more_than_60_days_ahead(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)
    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(start_date=date(2022, 1, 1), end_date=date(2022, 1, 30))
    ]
    application.has_continuous_leave_periods = True

    test_db_session.commit()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )
    response_body = response.get_json()

    assert response.status_code == 400

    errors = response_body.get("errors")

    assert {
        "message": "Can't submit application more than 60 days in advance of the earliest leave period",
        "rule": "disallow_submit_over_60_days_before_start_date",
        "type": "",
    } in errors


def test_application_post_submit_fineos_forbidden(client, fineos_user, fineos_user_token):
    application = ApplicationFactory.create(user=fineos_user)
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {fineos_user_token}"},
    )

    assert response.status_code == 403


def test_application_post_submit_ssn_fraud_error(
    client,
    user,
    consented_user,
    employer_user,
    auth_token,
    test_db_session,
    enable_application_fraud_check,
):
    # This tests the case where an application is submitted, but another application
    # with the same SSN but different user ids exists. These need to be handled
    # in the call center as they may be cases of fraud.

    # consented_user will have a different IDs, create another app with it
    assert user.sub_id != consented_user.sub_id
    assert user.sub_id != employer_user.sub_id

    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user, employer_fein=employer.employer_fein, tax_identifier=employee.tax_identifier
    )
    ApplicationFactory.create(user=employer_user, tax_identifier=application.tax_identifier)
    ApplicationFactory.create(user=consented_user, tax_identifier=application.tax_identifier)
    WagesAndContributionsFactory.create(employer=employer, employee=employee)

    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(start_date=date(2021, 1, 1))
    ]
    application.date_of_birth = date(1997, 6, 6)
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.hours_worked_per_week = 70
    application.has_continuous_leave_periods = True
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()

    test_db_session.commit()

    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    tests.api.validate_error_response(
        response,
        403,
        message="Application unable to be submitted by current user",
        errors=[
            {
                "message": "Request by current user not allowed",
                "rule": "disallow_attempts",
                "type": "",
            }
        ],
    )


def test_application_post_submit_ssn_second_app(
    client, user, auth_token, test_db_session, enable_application_fraud_check
):
    # This tests the case where an application is submitted, but another application
    # with the same SSN and same user exists.
    # This is in contrast to test_application_post_submit_ssn_fraud_error above
    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user, employer_fein=employer.employer_fein, tax_identifier=employee.tax_identifier
    )
    ApplicationFactory.create(user=user, tax_identifier=application.tax_identifier)
    WagesAndContributionsFactory.create(employer=employer, employee=employee)
    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(start_date=date(2021, 1, 1))
    ]
    application.date_of_birth = date(1997, 6, 6)
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.hours_worked_per_week = 70
    application.has_continuous_leave_periods = True
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()

    test_db_session.commit()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    response_body = response.get_json()
    assert response.status_code == 201
    assert not response_body.get("errors")
    assert not response_body.get("warnings")


def test_application_post_submit_app_fein_not_found(client, user, auth_token):
    # Assert that API returns a validation error when the application
    # includes an EIN that doesn't match an Employer record
    application = ApplicationFactory.create(user=user, employer_fein="999999999")

    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    response_body = response.get_json()
    errors = response_body.get("errors")

    assert {
        "field": "employer_fein",
        "message": "Confirm that you have the correct EIN, and that the Employer is contributing to Paid Family and Medical Leave.",
        "type": "require_contributing_employer",
    } in errors


def test_application_post_submit_app_ssn_not_found(client, user, auth_token, test_db_session):
    # An FEIN of 999999999 is simulated as not found in MockFINEOSClient.
    employer = EmployerFactory.create()
    tax_identifier = TaxIdentifierFactory.create(tax_identifier="999999999")
    application = ApplicationFactory.create(
        user=user, tax_identifier=tax_identifier, employer_fein=employer.employer_fein,
    )

    test_db_session.commit()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )
    response_body = response.get_json()

    assert {
        "message": "Couldn't find Employee in our system. Confirm that you have the correct EIN.",
        "rule": "require_employee",
        "type": "",
    } in response_body.get("errors")
    assert not response_body.get("warnings")
    # Simplified check to confirm Application was included in response:
    assert response_body.get("data").get("application_id") == str(application.application_id)
    assert not response_body.get("data").get("fineos_absence_id")
    assert response_body.get("data").get("status") == ApplicationStatus.Started.value


@mock.patch(
    "massgov.pfml.fineos.mock_client.MockFINEOSClient.get_customer_occupations_customer_api"
)
def test_application_post_submit_existing_work_pattern(
    mock_get_customer_occupations, client, user, auth_token, test_db_session
):
    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user, employer_fein=employer.employer_fein, tax_identifier=employee.tax_identifier
    )
    WagesAndContributionsFactory.create(employer=employer, employee=employee)

    application.hours_worked_per_week = 70
    application.first_name = "First"
    application.middle_name = "Middle"
    application.last_name = "Last"
    application.date_of_birth = date(1977, 7, 27)
    application.employer_notified = True
    application.employer_notification_date = date(2021, 1, 7)
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(start_date=date(2021, 1, 1))
    ]
    application.has_continuous_leave_periods = True

    mock_get_customer_occupations.return_value = [
        massgov.pfml.fineos.models.customer_api.ReadCustomerOccupation(
            occupationId=12345, hoursWorkedPerWeek=37.5, workPatternBasis="Week Based"
        )
    ]

    # set fineos user id in DB to avoid autogenerated id
    fineos_user_id = "USER_WITH_EXISTING_WORK_PATTERN"
    fineos_web_id_ext = FINEOSWebIdExt()
    fineos_web_id_ext.employee_tax_identifier = application.tax_identifier.tax_identifier
    fineos_web_id_ext.employer_fein = application.employer_fein
    fineos_web_id_ext.fineos_web_id = fineos_user_id
    test_db_session.add(fineos_web_id_ext)

    test_db_session.commit()
    massgov.pfml.fineos.mock_client.start_capture()

    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 201

    response_body = response.get_json()
    status = response_body.get("data").get("status")
    assert status == ApplicationStatus.Submitted.value

    capture = massgov.pfml.fineos.mock_client.get_capture()

    assert capture[2] == (
        "update_week_based_work_pattern",
        fineos_user_id,
        {
            "week_based_work_pattern": massgov.pfml.fineos.models.customer_api.WeekBasedWorkPattern(
                workPatternType="Fixed",
                workWeekStarts="Sunday",
                patternStartDate=None,
                patternStatus=None,
                workPatternDays=[
                    massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                        dayOfWeek="Sunday", weekNumber=1, hours=8, minutes=15
                    ),
                    massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                        dayOfWeek="Monday", weekNumber=1, hours=8, minutes=15
                    ),
                    massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                        dayOfWeek="Tuesday", weekNumber=1, hours=8, minutes=15
                    ),
                    massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                        dayOfWeek="Wednesday", weekNumber=1, hours=8, minutes=15
                    ),
                    massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                        dayOfWeek="Thursday", weekNumber=1, hours=8, minutes=15
                    ),
                    massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                        dayOfWeek="Friday", weekNumber=1, hours=8, minutes=15
                    ),
                    massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                        dayOfWeek="Saturday", weekNumber=1, hours=8, minutes=15
                    ),
                ],
            )
        },
    )

    assert capture[-1] == (
        "complete_intake",
        "USER_WITH_EXISTING_WORK_PATTERN",
        {"notification_case_id": "NTN-259"},
    )


def test_application_post_submit_to_fineos(client, user, auth_token, test_db_session):
    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user, employer_fein=employer.employer_fein, tax_identifier=employee.tax_identifier
    )
    WagesAndContributionsFactory.create(employer=employer, employee=employee)
    application.first_name = "First"
    application.middle_name = "Middle"
    application.last_name = "Last"
    application.date_of_birth = date(1977, 7, 27)
    application.mass_id = "S12345678"
    application.hours_worked_per_week = 70
    application.employer_notified = True
    application.phone = Phone(phone_number="+12404879945", phone_type_id=1, fineos_phone_id=111)
    application.employer_notification_date = date(2021, 1, 7)
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.residential_address = AddressFactory.create()
    application.gender_id = Gender.WOMAN.gender_id
    application.work_pattern = WorkPatternFixedFactory.create()
    application.has_continuous_leave_periods = True

    leave_period = ContinuousLeavePeriod(
        start_date=date(2021, 1, 1),
        end_date=date(2021, 2, 9),
        application_id=application.application_id,
    )
    test_db_session.add(leave_period)

    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()

    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 201

    response_body = response.get_json()
    status = response_body.get("data").get("status")
    assert status == ApplicationStatus.Submitted.value

    capture = massgov.pfml.fineos.mock_client.get_capture()

    # This is generated randomly and changes each time.
    fineos_user_id = capture[2][1]
    assert capture == [
        ("read_employer", None, {"employer_fein": application.employer_fein}),
        (
            "register_api_user",
            None,
            {
                "employee_registration": massgov.pfml.fineos.models.EmployeeRegistration(
                    user_id=fineos_user_id,
                    employer_id="999",
                    date_of_birth=date(1753, 1, 1),
                    national_insurance_no=application.tax_identifier.tax_identifier,
                )
            },
        ),
        (
            "update_customer_details",
            fineos_user_id,
            {
                "customer": massgov.pfml.fineos.models.customer_api.Customer(
                    firstName="First",
                    lastName="Last",
                    secondName="Middle",
                    dateOfBirth=date(1977, 7, 27),
                    idNumber=application.tax_identifier.tax_identifier,
                    customerAddress=massgov.pfml.fineos.models.customer_api.CustomerAddress(
                        address=massgov.pfml.fineos.models.customer_api.Address(
                            addressLine1=application.residential_address.address_line_one,
                            addressLine2=application.residential_address.address_line_two,
                            addressLine4=application.residential_address.city,
                            addressLine6=application.residential_address.geo_state.geo_state_description,
                            postCode=application.residential_address.zip_code,
                            country="USA",
                        ),
                    ),
                    gender="Female",
                    classExtensionInformation=[
                        massgov.pfml.fineos.models.customer_api.ExtensionAttribute(
                            name="MassachusettsID", stringValue=application.mass_id
                        ),
                        massgov.pfml.fineos.models.customer_api.ExtensionAttribute(
                            name="Confirmed", booleanValue=True
                        ),
                        massgov.pfml.fineos.models.customer_api.ExtensionAttribute(
                            name="ConsenttoShareData", booleanValue=False
                        ),
                    ],
                )
            },
        ),
        (
            "get_customer_occupations_customer_api",
            fineos_user_id,
            {"customer_id": application.tax_identifier.tax_identifier},
        ),
        (
            "add_week_based_work_pattern",
            fineos_user_id,
            {
                "week_based_work_pattern": massgov.pfml.fineos.models.customer_api.WeekBasedWorkPattern(
                    workPatternType="Fixed",
                    workWeekStarts="Sunday",
                    patternStartDate=None,
                    patternStatus=None,
                    workPatternDays=[
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Sunday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Monday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Tuesday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Wednesday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Thursday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Friday", weekNumber=1, hours=8, minutes=15
                        ),
                        massgov.pfml.fineos.models.customer_api.WorkPatternDay(
                            dayOfWeek="Saturday", weekNumber=1, hours=8, minutes=15
                        ),
                    ],
                )
            },
        ),
        (
            "update_occupation",
            None,
            {
                "employment_status": "Terminated",
                "fineos_org_unit_id": None,
                "hours_worked_per_week": 70,
                "occupation_id": 12345,
                "worksite_id": None,
            },
        ),
        (
            "start_absence",
            fineos_user_id,
            {
                "absence_case": massgov.pfml.fineos.models.customer_api.AbsenceCase(
                    additionalComments="PFML API " + str(application.application_id),
                    intakeSource="Self-Service",
                    notifiedBy="Employee",
                    reason="Serious Health Condition - Employee",
                    reasonQualifier1="Not Work Related",
                    reasonQualifier2="Sickness",
                    notificationReason="Accident or treatment required for an injury",
                    primaryRelationship=None,
                    primaryRelQualifier1=None,
                    primaryRelQualifier2=None,
                    timeOffLeavePeriods=[
                        massgov.pfml.fineos.models.customer_api.TimeOffLeavePeriod(
                            startDate=date(2021, 1, 1),
                            endDate=date(2021, 2, 9),
                            startDateFullDay=True,
                            endDateFullDay=True,
                            status="known",
                        )
                    ],
                    employerNotified=True,
                    employerNotificationDate=date(2021, 1, 7),
                    employerNotificationMethod=None,
                )
            },
        ),
        (
            "update_customer_contact_details",
            fineos_user_id,
            {
                "contact_details": massgov.pfml.fineos.models.customer_api.ContactDetails(
                    phoneNumbers=[
                        massgov.pfml.fineos.models.customer_api.PhoneNumber(
                            id=111,
                            preferred=None,
                            phoneNumberType="Cell",
                            intCode="1",
                            areaCode="240",
                            telephoneNo="4879945",
                            classExtensionInformation=None,
                        )
                    ],
                    emailAddresses=[
                        massgov.pfml.fineos.models.customer_api.EmailAddress(
                            emailAddress=application.user.email_address
                        )
                    ],
                )
            },
        ),
        ("complete_intake", fineos_user_id, {"notification_case_id": "NTN-259"}),
    ]


def test_application_post_submit_to_fineos_intermittent_leave(
    client, user, auth_token, test_db_session
):
    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user, employer_fein=employer.employer_fein, tax_identifier=employee.tax_identifier
    )
    WagesAndContributionsFactory.create(employer=employer, employee=employee)
    application.hours_worked_per_week = 70
    application.employer_notified = True
    application.employer_notification_date = date(2021, 1, 7)
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.work_pattern = WorkPatternFixedFactory.create()
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()

    leave_period = IntermittentLeavePeriodFactory.create(
        application_id=application.application_id,
        start_date=date(2021, 1, 1),
        end_date=date(2021, 3, 2),
        duration=3,
        duration_basis=DurationBasis.days.value,
        frequency=6,
        frequency_interval=2,
        frequency_interval_basis=FrequencyIntervalBasis.months.value,
    )

    application.intermittent_leave_periods = [leave_period]
    application.has_intermittent_leave_periods = True

    test_db_session.add(application)

    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()

    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 201

    response_body = response.get_json()
    status = response_body.get("data").get("status")
    assert status == ApplicationStatus.Submitted.value

    capture = massgov.pfml.fineos.mock_client.get_capture()

    assert capture[6][2]["absence_case"].episodicLeavePeriods == [
        massgov.pfml.fineos.models.customer_api.EpisodicLeavePeriod(
            startDate=date(2021, 1, 1),
            endDate=date(2021, 3, 2),
            duration=3,
            durationBasis="Days",
            frequency=6,
            frequencyInterval=2,
            frequencyIntervalBasis="Months",
        )
    ]


def test_application_post_submit_to_fineos_reduced_schedule_leave(
    client, user, auth_token, test_db_session
):
    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user, employer_fein=employer.employer_fein, tax_identifier=employee.tax_identifier
    )
    WagesAndContributionsFactory.create(employer=employer, employee=employee)

    application.hours_worked_per_week = 70
    application.employer_notified = True
    application.employer_notification_date = date(2021, 1, 7)
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.work_pattern = WorkPatternFixedFactory.create()
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()

    leave_period = ReducedScheduleLeavePeriodFactory.create(
        application_id=application.application_id,
        start_date=date(2021, 1, 1),
        end_date=date(2021, 2, 9),
        thursday_off_minutes=240 + 45,
        friday_off_minutes=480,
        saturday_off_minutes=0,
        sunday_off_minutes=45,
        monday_off_minutes=240 + 15,
        tuesday_off_minutes=60,
        wednesday_off_minutes=240 + 30,
    )
    application.reduced_schedule_leave_periods = [leave_period]
    application.has_reduced_schedule_leave_periods = True

    test_db_session.add(application)
    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()

    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 201

    response_body = response.get_json()
    status = response_body.get("data").get("status")
    assert status == ApplicationStatus.Submitted.value

    capture = massgov.pfml.fineos.mock_client.get_capture()

    assert capture[6][2]["absence_case"].reducedScheduleLeavePeriods == [
        massgov.pfml.fineos.models.customer_api.ReducedScheduleLeavePeriod(
            startDate=date(2021, 1, 1),
            endDate=date(2021, 2, 9),
            status="known",
            mondayOffHours=4,
            mondayOffMinutes=15,
            tuesdayOffHours=1,
            tuesdayOffMinutes=0,
            wednesdayOffHours=4,
            wednesdayOffMinutes=30,
            thursdayOffHours=4,
            thursdayOffMinutes=45,
            fridayOffHours=8,
            fridayOffMinutes=0,
            saturdayOffHours=0,
            saturdayOffMinutes=0,
            sundayOffHours=0,
            sundayOffMinutes=45,
        )
    ]


def test_application_post_submit_to_fineos_bonding_adoption(
    client, user, auth_token, test_db_session
):
    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user, employer_fein=employer.employer_fein, tax_identifier=employee.tax_identifier
    )
    WagesAndContributionsFactory.create(employer=employer, employee=employee)
    application.hours_worked_per_week = 70
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    leave_period = ContinuousLeavePeriod(
        start_date=date(2021, 1, 1),
        end_date=date(2021, 2, 9),
        application_id=application.application_id,
    )
    test_db_session.add(leave_period)

    # Reason = Child Bonding
    # Reason Qualifier 1 = Adoption
    application.leave_reason_id = LeaveReason.CHILD_BONDING.leave_reason_id
    application.leave_reason_qualifier_id = LeaveReasonQualifier.ADOPTION.leave_reason_qualifier_id

    application.child_placement_date = date(2021, 1, 15)
    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )
    assert response.status_code == 201

    capture = massgov.pfml.fineos.mock_client.get_capture()
    captured_absence_case = capture[6][2]["absence_case"]

    assert captured_absence_case.reason == LeaveReason.CHILD_BONDING.leave_reason_description
    assert (
        captured_absence_case.reasonQualifier1
        == LeaveReasonQualifier.ADOPTION.leave_reason_qualifier_description
    )
    assert captured_absence_case.reasonQualifier2 is None
    assert (
        captured_absence_case.primaryRelationship
        == RelationshipToCaregiver.CHILD.relationship_to_caregiver_description
    )
    assert (
        captured_absence_case.primaryRelQualifier1
        == RelationshipQualifier.ADOPTED.relationship_qualifier_description
    )
    assert captured_absence_case.primaryRelQualifier2 is None


def test_application_post_submit_to_fineos_bonding_foster(
    client, user, auth_token, test_db_session
):
    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user, employer_fein=employer.employer_fein, tax_identifier=employee.tax_identifier
    )
    WagesAndContributionsFactory.create(employer=employer, employee=employee)
    application.hours_worked_per_week = 70
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    leave_period = ContinuousLeavePeriod(
        start_date=date(2021, 1, 1),
        end_date=date(2021, 2, 9),
        application_id=application.application_id,
    )
    test_db_session.add(leave_period)

    # Reason = Child Bonding
    # Reason Qualifier 1 = Foster Care
    application.leave_reason_id = LeaveReason.CHILD_BONDING.leave_reason_id
    application.leave_reason_qualifier_id = (
        LeaveReasonQualifier.FOSTER_CARE.leave_reason_qualifier_id
    )
    application.child_placement_date = date(2020, 2, 1)
    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 201

    capture = massgov.pfml.fineos.mock_client.get_capture()
    captured_absence_case = capture[6][2]["absence_case"]

    assert captured_absence_case.reason == LeaveReason.CHILD_BONDING.leave_reason_description
    assert (
        captured_absence_case.reasonQualifier1
        == LeaveReasonQualifier.FOSTER_CARE.leave_reason_qualifier_description
    )
    assert captured_absence_case.reasonQualifier2 is None
    assert (
        captured_absence_case.primaryRelationship
        == RelationshipToCaregiver.CHILD.relationship_to_caregiver_description
    )
    assert (
        captured_absence_case.primaryRelQualifier1
        == RelationshipQualifier.FOSTER.relationship_qualifier_description
    )
    assert captured_absence_case.primaryRelQualifier2 is None


def test_application_post_submit_to_fineos_bonding_newborn(
    client, user, auth_token, test_db_session
):
    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user, employer_fein=employer.employer_fein, tax_identifier=employee.tax_identifier
    )
    WagesAndContributionsFactory.create(employer=employer, employee=employee)
    application.hours_worked_per_week = 70
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    leave_period = ContinuousLeavePeriod(
        start_date=date(2021, 1, 1),
        end_date=date(2021, 2, 9),
        application_id=application.application_id,
    )
    test_db_session.add(leave_period)

    # Reason = Child Bonding
    # Reason Qualifier 1 = Newborn
    application.leave_reason_id = LeaveReason.CHILD_BONDING.leave_reason_id
    application.leave_reason_qualifier_id = LeaveReasonQualifier.NEWBORN.leave_reason_qualifier_id

    application.child_birth_date = date(2020, 2, 1)
    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 201

    capture = massgov.pfml.fineos.mock_client.get_capture()
    captured_absence_case = capture[6][2]["absence_case"]

    assert captured_absence_case.reason == LeaveReason.CHILD_BONDING.leave_reason_description
    assert (
        captured_absence_case.reasonQualifier1
        == LeaveReasonQualifier.NEWBORN.leave_reason_qualifier_description
    )
    assert captured_absence_case.reasonQualifier2 is None
    assert (
        captured_absence_case.primaryRelationship
        == RelationshipToCaregiver.CHILD.relationship_to_caregiver_description
    )
    assert (
        captured_absence_case.primaryRelQualifier1
        == RelationshipQualifier.BIOLOGICAL.relationship_qualifier_description
    )
    assert captured_absence_case.primaryRelQualifier2 is None


def test_application_post_submit_to_fineos_medical(client, user, auth_token, test_db_session):
    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user, employer_fein=employer.employer_fein, tax_identifier=employee.tax_identifier
    )
    WagesAndContributionsFactory.create(employer=employer, employee=employee)
    application.hours_worked_per_week = 70
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    leave_period = ContinuousLeavePeriod(
        start_date=date(2021, 1, 1),
        end_date=date(2021, 2, 9),
        application_id=application.application_id,
    )
    test_db_session.add(leave_period)

    # API input:
    # Reason = Serious Health Condition - Employee
    # Pregnant or Recent Birth = False
    application.leave_reason_id = LeaveReason.SERIOUS_HEALTH_CONDITION_EMPLOYEE.leave_reason_id
    application.pregnant_or_recent_birth = False
    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 201

    capture = massgov.pfml.fineos.mock_client.get_capture()
    captured_absence_case = capture[6][2]["absence_case"]

    # Maps to FINEOS:
    # Reason = Serious Health Condition - Employee
    # Reason Qualifier 1 = Not Work Related
    # Reason Qualifier 2 = Sickness
    assert (
        captured_absence_case.reason
        == LeaveReason.SERIOUS_HEALTH_CONDITION_EMPLOYEE.leave_reason_description
    )
    assert (
        captured_absence_case.reasonQualifier1
        == LeaveReasonQualifier.NOT_WORK_RELATED.leave_reason_qualifier_description
    )
    assert (
        captured_absence_case.reasonQualifier2
        == LeaveReasonQualifier.SICKNESS.leave_reason_qualifier_description
    )
    assert captured_absence_case.primaryRelationship is None
    assert captured_absence_case.primaryRelQualifier1 is None
    assert captured_absence_case.primaryRelQualifier2 is None


def test_application_post_submit_to_fineos_pregnant_true(client, user, auth_token, test_db_session):
    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user, employer_fein=employer.employer_fein, tax_identifier=employee.tax_identifier
    )
    WagesAndContributionsFactory.create(employer=employer, employee=employee)
    application.hours_worked_per_week = 70
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    leave_period = ContinuousLeavePeriod(
        start_date=date(2021, 1, 1),
        end_date=date(2021, 2, 9),
        application_id=application.application_id,
    )
    test_db_session.add(leave_period)

    # API input:
    # Reason = Pregnancy/Maternity
    # Pregnant or Recent Birth = True
    application.leave_reason_id = LeaveReason.PREGNANCY_MATERNITY.leave_reason_id
    application.pregnant_or_recent_birth = True
    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 201

    capture = massgov.pfml.fineos.mock_client.get_capture()
    captured_absence_case = capture[6][2]["absence_case"]

    # Maps to FINEOS:
    # Reason = Pregnancy/Maternity
    # Reason Qualifier 1 = Postnatal Disability
    assert captured_absence_case.reason == LeaveReason.PREGNANCY_MATERNITY.leave_reason_description
    assert (
        captured_absence_case.reasonQualifier1
        == LeaveReasonQualifier.POSTNATAL_DISABILITY.leave_reason_qualifier_description
    )
    assert captured_absence_case.reasonQualifier2 is None
    assert captured_absence_case.primaryRelationship is None
    assert captured_absence_case.primaryRelQualifier1 is None
    assert captured_absence_case.primaryRelQualifier2 is None


def test_application_post_submit_to_fineos_pregnant(client, user, auth_token, test_db_session):
    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user, employer_fein=employer.employer_fein, tax_identifier=employee.tax_identifier
    )
    WagesAndContributionsFactory.create(employer=employer, employee=employee)
    application.hours_worked_per_week = 70
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    leave_period = ContinuousLeavePeriod(
        start_date=date(2021, 1, 1),
        end_date=date(2021, 2, 9),
        application_id=application.application_id,
    )
    test_db_session.add(leave_period)

    # API input:
    # Reason = Pregnancy/Maternity
    # Pregnant or Recent Birth = False
    application.leave_reason_id = LeaveReason.PREGNANCY_MATERNITY.leave_reason_id
    application.pregnant_or_recent_birth = False
    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 201

    capture = massgov.pfml.fineos.mock_client.get_capture()
    captured_absence_case = capture[6][2]["absence_case"]

    # Maps to FINEOS:
    # Reason = Pregnancy/Maternity
    # Reason Qualifier 1 = Postnatal Disability
    assert captured_absence_case.reason == LeaveReason.PREGNANCY_MATERNITY.leave_reason_description
    assert (
        captured_absence_case.reasonQualifier1
        == LeaveReasonQualifier.POSTNATAL_DISABILITY.leave_reason_qualifier_description
    )
    assert captured_absence_case.reasonQualifier2 is None
    assert captured_absence_case.primaryRelationship is None
    assert captured_absence_case.primaryRelQualifier1 is None
    assert captured_absence_case.primaryRelQualifier2 is None


def test_application_post_submit_app_failure_after_absence_case_creation(
    client, user, auth_token, test_db_session
):
    claim = ClaimFactory.create(
        fineos_notification_id="NTN-1989", fineos_absence_id="NTN-1989-ABS-01"
    )
    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user, employer_fein=employer.employer_fein, tax_identifier=employee.tax_identifier
    )
    WagesAndContributionsFactory.create(employer=employer, employee=employee)

    # Fill in required fields so this is an valid application apart from the fact it's already been submitted.
    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(start_date=date(2021, 1, 1))
    ]
    application.date_of_birth = date(1997, 6, 6)
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.hours_worked_per_week = 70
    application.has_continuous_leave_periods = True
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()

    # Attach absence case information application so it appears as if this application has already been submitted.
    application.claim = claim
    application.submitted_time = datetime_util.utcnow()
    test_db_session.commit()

    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    assert response.status_code == 403


def test_application_post_submit_creates_previous_leaves_eform(
    client, user, auth_token, test_db_session
):
    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user, employer_fein=employer.employer_fein, tax_identifier=employee.tax_identifier
    )
    WagesAndContributionsFactory.create(employer=employer, employee=employee)
    application.hours_worked_per_week = 40
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(start_date=date(2021, 1, 1))
    ]
    application.previous_leaves_same_reason = [
        PreviousLeaveSameReasonFactory.create(application_id=application.application_id)
    ]
    application.previous_leaves_other_reason = [
        PreviousLeaveOtherReasonFactory.create(application_id=application.application_id)
    ]

    massgov.pfml.fineos.mock_client.start_capture()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    captures = massgov.pfml.fineos.mock_client.get_capture()

    assert response.status_code == 201
    filtered = list(filter(lambda cap: cap[0] == "customer_create_eform", captures))
    assert len(filtered) == 1
    create_eform_capture = filtered[0]
    assert create_eform_capture[2]["eform"].eformType == "Other Leaves - current version"
    eform_attributes = create_eform_capture[2]["eform"].eformAttributes
    previous_leave_reason = next(
        (attr for attr in eform_attributes if attr["name"] == "V2QualifyingReason2"), None
    )
    assert previous_leave_reason["enumValue"]["instanceValue"] == "An illness or injury"


def test_application_post_submit_no_previous_leaves_does_not_create_other_leaves_eform(
    client, user, auth_token, test_db_session
):
    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user, employer_fein=employer.employer_fein, tax_identifier=employee.tax_identifier
    )
    WagesAndContributionsFactory.create(employer=employer, employee=employee)
    application.hours_worked_per_week = 40
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(start_date=date(2021, 1, 1))
    ]
    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    captures = massgov.pfml.fineos.mock_client.get_capture()

    assert response.status_code == 201
    assert "customer_create_eform" not in map(lambda capture: capture[0], captures)


def test_application_post_submit_creates_other_incomes_eform(
    client, user, auth_token, test_db_session
):
    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user, employer_fein=employer.employer_fein, tax_identifier=employee.tax_identifier
    )
    WagesAndContributionsFactory.create(employer=employer, employee=employee)
    application.hours_worked_per_week = 40
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(start_date=date(2021, 1, 1))
    ]
    application.employer_benefits = [
        EmployerBenefitFactory.create(application_id=application.application_id)
    ]

    massgov.pfml.fineos.mock_client.start_capture()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    captures = massgov.pfml.fineos.mock_client.get_capture()

    assert response.status_code == 201
    filtered = list(filter(lambda cap: cap[0] == "customer_create_eform", captures))
    assert len(filtered) == 1
    create_eform_capture = filtered[0]
    assert create_eform_capture[2]["eform"].eformType == "Other Income - current version"


def test_application_post_submit_no_benefits_or_incomes_does_not_create_other_incomes_eform(
    client, user, auth_token, test_db_session
):
    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user, employer_fein=employer.employer_fein, tax_identifier=employee.tax_identifier
    )
    WagesAndContributionsFactory.create(employer=employer, employee=employee)
    application.hours_worked_per_week = 40
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(start_date=date(2021, 1, 1))
    ]
    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()
    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    captures = massgov.pfml.fineos.mock_client.get_capture()

    assert response.status_code == 201
    assert "customer_create_eform" not in map(lambda capture: capture[0], captures)


def test_application_post_submit_to_fineos_caring_leave(client, user, auth_token, test_db_session):
    caring_leave_metadata = CaringLeaveMetadataFactory.create(
        relationship_to_caregiver_id=RelationshipToCaregiver.SPOUSE.relationship_to_caregiver_id
    )
    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user,
        employer_fein=employer.employer_fein,
        tax_identifier=employee.tax_identifier,
        caring_leave_metadata=caring_leave_metadata,
    )
    WagesAndContributionsFactory.create(employer=employer, employee=employee)
    application.hours_worked_per_week = 40
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    leave_period = ContinuousLeavePeriod(
        start_date=date(2021, 7, 1),
        end_date=date(2021, 8, 9),
        application_id=application.application_id,
    )
    test_db_session.add(leave_period)

    application.leave_reason_id = LeaveReason.CARE_FOR_A_FAMILY_MEMBER.leave_reason_id
    test_db_session.commit()

    massgov.pfml.fineos.mock_client.start_capture()

    response = client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    capture = massgov.pfml.fineos.mock_client.get_capture()
    captured_absence_case = capture[6][2]["absence_case"]

    assert response.status_code == 201
    assert (
        captured_absence_case.reason
        == LeaveReason.CARE_FOR_A_FAMILY_MEMBER.leave_reason_description
    )
    assert (
        captured_absence_case.reasonQualifier1
        == LeaveReasonQualifier.SERIOUS_HEALTH_CONDITION.leave_reason_qualifier_description
    )
    assert (
        captured_absence_case.notificationReason
        == LeaveNotificationReason.CARING_FOR_A_FAMILY_MEMBER
    )
    assert (
        captured_absence_case.primaryRelationship
        == RelationshipToCaregiver.SPOUSE.relationship_to_caregiver_description
    )
    assert (
        captured_absence_case.primaryRelQualifier1
        == RelationshipQualifier.LEGALLY_MARRIED.relationship_qualifier_description
    )
    assert (
        captured_absence_case.primaryRelQualifier2
        == RelationshipQualifier.UNDISCLOSED.relationship_qualifier_description
    )


def test_application_post_complete_app(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user)
    claim = ClaimFactory.create(
        fineos_notification_id="NTN-1989", fineos_absence_id="NTN-1989-ABS-01"
    )
    application.tax_identifier = TaxIdentifier(tax_identifier="999004444")
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.hours_worked_per_week = 70
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    application.claim = claim
    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(start_date=date(2021, 1, 1))
    ]
    application.has_continuous_leave_periods = True

    test_db_session.commit()

    response = client.post(
        "/v1/applications/{}/complete_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    response_body = response.get_json()

    assert response.status_code == 200
    assert response_body.get("data").get("status") == ApplicationStatus.Completed.value


def test_application_post_complete_app_without_other_leave_fields(
    client, user, auth_token, test_db_session
):
    # TODO (CP-2455): Remove this test when we begin requiring these fields for complete_application
    application = ApplicationFactory.create(
        user=user,
        has_concurrent_leave=None,
        has_employer_benefits=None,
        has_other_incomes=None,
        has_previous_leaves_other_reason=None,
        has_previous_leaves_same_reason=None,
        submitted_time=datetime.now(),
    )
    claim = ClaimFactory.create(
        fineos_notification_id="NTN-1989", fineos_absence_id="NTN-1989-ABS-01"
    )
    application.tax_identifier = TaxIdentifier(tax_identifier="999004444")
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.hours_worked_per_week = 70
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    application.claim = claim
    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(start_date=date(2021, 1, 1))
    ]
    application.has_continuous_leave_periods = True

    test_db_session.commit()

    response = client.post(
        "/v1/applications/{}/complete_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    response_body = response.get_json()

    assert response.status_code == 200
    assert response_body.get("data").get("status") == ApplicationStatus.Completed.value


def test_application_complete_mark_document_received_fineos(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(user=user)
    claim = ClaimFactory.create(
        fineos_notification_id="NTN-1989", fineos_absence_id="NTN-1989-ABS-01"
    )
    application.tax_identifier = TaxIdentifier(tax_identifier="999004444")
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.hours_worked_per_week = 70
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    application.claim = claim
    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(
            # Dates that pass validation criteria. 55 and 75 are not meaningful values outside
            # of the fact that they are valid. Would work with any valid leave period.
            start_date=(datetime.now() + relativedelta(days=55)).date(),
            end_date=(datetime.now() + relativedelta(days=75)).date(),
        )
    ]
    application.has_continuous_leave_periods = True

    test_db_session.add(application)

    id_proof = DocumentFactory.create(
        user_id=user.user_id,
        application_id=application.application_id,
        document_type_id=DocumentType.IDENTIFICATION_PROOF.document_type_id,
        fineos_id="id-proof-dummy-doc-id",
    )
    test_db_session.add(id_proof)

    irrelevant_evidence = DocumentFactory.create(
        user_id=user.user_id,
        application_id=application.application_id,
        document_type_id=DocumentType.PASSPORT.document_type_id,
        fineos_id="passport-dummy-doc-id",
    )
    test_db_session.add(irrelevant_evidence)

    test_db_session.commit()

    assert not application.completed_time

    massgov.pfml.fineos.mock_client.start_capture()

    response = client.post(
        "/v1/applications/{}/complete_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )
    assert response.status_code == 200

    capture = massgov.pfml.fineos.mock_client.get_capture()

    # Refresh the db session because the application object was manipulated by another session
    # in the logic we executed as a result of the POST request above.
    test_db_session.refresh(application)
    assert application.completed_time

    client_function_calls = (
        "find_employer",
        "register_api_user",
        "mark_document_as_received",
    )
    for i in range(len(capture)):
        assert capture[i][0] == client_function_calls[i]

    assert (
        len(capture) == 3
    ), "Did not make 3 requests to FINEOS API. Confirm that we did not attempt to mark_document_as_received for irrelevant_evidence"

    # Function name
    assert capture[2][0] == "mark_document_as_received"

    # Arguments we pass to the function
    assert capture[2][2] == {
        "absence_id": application.claim.fineos_absence_id,
        "fineos_document_id": id_proof.fineos_id,
    }


def test_application_patch_null_benefits(
    client, user, auth_token, test_db_session, initialize_factories_session
):
    # employer_benefits
    application = ApplicationFactory.create(user=user, updated_at=datetime.now())
    EmployerBenefitFactory.create(application_id=application.application_id)

    update_request_body = {
        "employer_benefits": None,
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    response_body = response.get_json().get("data")
    test_db_session.refresh(application)

    assert response.status_code == 200
    assert len(response_body.get("employer_benefits")) == 0
    assert len(application.employer_benefits) == 0

    # other_incomes
    OtherIncomeFactory.create(application_id=application.application_id)

    update_request_body = {"other_incomes": None}

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    response_body = response.get_json().get("data")
    test_db_session.refresh(application)

    assert response.status_code == 200
    assert len(response_body.get("other_incomes")) == 0
    assert len(application.other_incomes) == 0

    # previous_leaves
    PreviousLeaveOtherReasonFactory.create(application_id=application.application_id)

    update_request_body = {"previous_leaves_other_reason": None}

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    response_body = response.get_json().get("data")
    test_db_session.refresh(application)

    assert response.status_code == 200
    assert len(response_body.get("previous_leaves_other_reason")) == 0
    assert len(application.previous_leaves_other_reason) == 0


def test_application_patch_benefits_empty_arrays(
    client, user, auth_token, test_db_session, initialize_factories_session
):
    # employer_benefits
    application = ApplicationFactory.create(user=user, updated_at=datetime.now())
    EmployerBenefitFactory.create(application_id=application.application_id)

    update_request_body = {
        "employer_benefits": [],
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    response_body = response.get_json().get("data")
    test_db_session.refresh(application)

    assert response.status_code == 200
    assert len(response_body.get("employer_benefits")) == 0
    assert len(application.employer_benefits) == 0

    # other_incomes
    OtherIncomeFactory.create(application_id=application.application_id)

    update_request_body = {"other_incomes": []}

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    response_body = response.get_json().get("data")
    test_db_session.refresh(application)

    assert response.status_code == 200
    assert len(response_body.get("other_incomes")) == 0
    assert len(application.other_incomes) == 0

    # previous_leaves
    PreviousLeaveSameReasonFactory.create(application_id=application.application_id)

    update_request_body = {"previous_leaves_same_reason": []}

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    response_body = response.get_json().get("data")
    test_db_session.refresh(application)

    assert response.status_code == 200
    assert len(response_body.get("previous_leaves_same_reason")) == 0
    assert len(application.previous_leaves_same_reason) == 0


# TODO: refactor existing update_application tests to use this class and fixtures
# https://lwd.atlassian.net/browse/CP-2331
class TestApplicationsUpdate:
    @pytest.fixture
    def application(self, user):
        application = ApplicationFactory.create(user=user, updated_at=datetime.now())
        EmployerBenefitFactory.create(application_id=application.application_id)

        return application

    @pytest.fixture
    def address(self):
        return massgov.pfml.api.models.applications.common.Address(
            line_1="123 Main St.", city="Boston", state="Massachusetts", zip="02111"
        )

    # Collects the params necessary for making a request with a valid application update
    # to the mock API client
    @pytest.fixture
    def request_params(self, application, auth_token):
        class UpdateApplicationRequestParams(object):
            __slots__ = ["application_id", "auth_token", "body"]

            def __init__(self, application_id, auth_token, body):
                self.application_id = application_id
                self.auth_token = auth_token
                self.body = body

        return UpdateApplicationRequestParams(application.application_id, auth_token, {})

    # Submits an application update request with the given params
    def perform_update(self, client, request_params):
        return client.patch(
            "/v1/applications/{}".format(request_params.application_id),
            headers={"Authorization": f"Bearer {request_params.auth_token}"},
            json=request_params.body,
        )

    def test_success(self, client, request_params):
        request_body = {}
        request_body["first_name"] = "Foo"
        request_params.body = request_body

        response = self.perform_update(client, request_params)
        assert response.status_code == 200

    @pytest.mark.parametrize("name_field", ["first_name", "middle_name", "last_name"])
    def test_name_field_too_long(self, client, request_params, name_field):
        name = "a" * 51

        request_body = {}
        request_body[name_field] = name
        request_params.body = request_body

        response = self.perform_update(client, request_params)
        assert response.status_code == 400

        errors = response.get_json().get("errors")
        assert len(errors) == 1

        error = errors[0]
        assert error.get("type") == "maxLength"
        assert error.get("field") == name_field

    @pytest.mark.parametrize("address_field", ["line_1", "line_2", "city", "state"])
    def test_address_field_too_long(self, client, request_params, address, address_field):
        address_dict = address.__dict__
        address_dict[address_field] = "a" * 41

        request_body = {}
        request_body["residential_address"] = address_dict
        request_params.body = request_body

        response = self.perform_update(client, request_params)
        assert response.status_code == 400

        errors = response.get_json().get("errors")
        assert len(errors) == 1

        error = errors[0]
        assert error.get("type") == "maxLength"
        assert error.get("field") == f"residential_address.{address_field}"


def test_application_post_submit_app_creates_claim(client, user, auth_token, test_db_session):
    employer = EmployerFactory.create()
    employee = EmployeeFactory.create()
    application = ApplicationFactory.create(
        user=user, employer_fein=employer.employer_fein, tax_identifier=employee.tax_identifier
    )
    WagesAndContributionsFactory.create(employer=employer, employee=employee)

    startDate = date(2021, 1, 1)
    endDate = date(2021, 4, 1)

    application.continuous_leave_periods = [
        ContinuousLeavePeriodFactory.create(start_date=startDate, end_date=endDate)
    ]
    application.date_of_birth = date(1997, 6, 6)
    application.employment_status_id = EmploymentStatus.UNEMPLOYED.employment_status_id
    application.hours_worked_per_week = 70
    application.has_continuous_leave_periods = True
    application.residential_address = AddressFactory.create()
    application.work_pattern = WorkPatternFixedFactory.create()
    application.leave_reason_id = 4
    application.leave_reason_qualifier_id = 7

    test_db_session.commit()
    client.post(
        "/v1/applications/{}/submit_application".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
    )

    submitted_application = (
        test_db_session.query(Application)
        .filter(Application.application_id == application.application_id)
        .one_or_none()
    )

    assert submitted_application.claim is not None
    assert submitted_application.claim.employer is not None
    assert submitted_application.claim.absence_period_start_date == startDate
    assert submitted_application.claim.absence_period_end_date == endDate
    assert submitted_application.claim.claim_type_id == 2


def test_submit_app_with_leave_reason_id_not_in_map(client, user, auth_token, test_db_session):
    with pytest.raises(NoClaimTypeForAbsenceType):
        new_leave_reason = LeaveReasonFactory.create(
            leave_reason_id=999, leave_reason_description="New reason"
        )
        new_leave_reason.absence_to_claim_type


def test_application_patch_caring_leave_metadata(client, user, auth_token, test_db_session):
    application = ApplicationFactory.create(user=user, phone=None)
    assert (
        application.leave_reason_id == LeaveReason.SERIOUS_HEALTH_CONDITION_EMPLOYEE.leave_reason_id
    )
    assert application.caring_leave_metadata is None

    caring_leave_metadata = CaringLeaveMetadataFactory.create()
    application.caring_leave_metadata = caring_leave_metadata
    test_db_session.add(caring_leave_metadata)
    test_db_session.add(application)
    test_db_session.commit()

    # change leave reason to caring leave
    update_request_body = {
        "leave_details": {"reason": LeaveReason.CARE_FOR_A_FAMILY_MEMBER.leave_reason_description}
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    assert response.status_code == 200
    assert application.leave_reason_id == LeaveReason.CARE_FOR_A_FAMILY_MEMBER.leave_reason_id

    # updating caring leave data
    update_request_body = {
        "leave_details": {
            "caring_leave_metadata": {
                "family_member_first_name": "Jane",
                "family_member_middle_name": "Alice",
                "family_member_last_name": "Doe",
                "family_member_date_of_birth": "1975-01-01",
                "relationship_to_caregiver": RelationshipToCaregiver.PARENT.relationship_to_caregiver_description,
            }
        }
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    assert response.status_code == 200

    test_db_session.refresh(application)
    assert application.caring_leave_metadata.family_member_first_name == "Jane"
    assert application.caring_leave_metadata.family_member_middle_name == "Alice"
    assert application.caring_leave_metadata.family_member_last_name == "Doe"
    assert application.caring_leave_metadata.family_member_date_of_birth.isoformat() == "1975-01-01"
    assert (
        application.caring_leave_metadata.relationship_to_caregiver_id
        == RelationshipToCaregiver.PARENT.relationship_to_caregiver_id
    )

    response_body = response.get_json()
    response_caring_leave_metadata = (
        response_body.get("data").get("leave_details").get("caring_leave_metadata")
    )
    assert (
        response_caring_leave_metadata["family_member_first_name"]
        == update_request_body["leave_details"]["caring_leave_metadata"]["family_member_first_name"]
    )
    assert (
        response_caring_leave_metadata["family_member_middle_name"]
        == update_request_body["leave_details"]["caring_leave_metadata"][
            "family_member_middle_name"
        ]
    )
    assert (
        response_caring_leave_metadata["family_member_last_name"]
        == update_request_body["leave_details"]["caring_leave_metadata"]["family_member_last_name"]
    )
    assert response_caring_leave_metadata["family_member_date_of_birth"] == "****-01-01"
    assert (
        response_caring_leave_metadata["relationship_to_caregiver"]
        == update_request_body["leave_details"]["caring_leave_metadata"][
            "relationship_to_caregiver"
        ]
    )


def test_application_patch_caring_leave_metadata_issues(client, user, auth_token, test_db_session):
    caring_leave_metadata_issues = [
        {
            "field": "leave_details.caring_leave_metadata.family_member_first_name",
            "message": "leave_details.caring_leave_metadata.family_member_first_name is required",
            "type": "required",
        },
        {
            "field": "leave_details.caring_leave_metadata.family_member_last_name",
            "message": "leave_details.caring_leave_metadata.family_member_last_name is required",
            "type": "required",
        },
        {
            "field": "leave_details.caring_leave_metadata.family_member_date_of_birth",
            "message": "leave_details.caring_leave_metadata.family_member_date_of_birth is required",
            "type": "required",
        },
        {
            "field": "leave_details.caring_leave_metadata.relationship_to_caregiver",
            "message": "leave_details.caring_leave_metadata.relationship_to_caregiver is required",
            "type": "required",
        },
    ]

    application = ApplicationFactory.create(
        user=user, phone=None, leave_reason_id=LeaveReason.CARE_FOR_A_FAMILY_MEMBER.leave_reason_id
    )
    assert application.caring_leave_metadata is None

    # patch without data
    update_request_body = {"leave_details": {"caring_leave_metadata": {}}}

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_warnings = response.get_json().get("warnings")

    assert response.status_code == 200
    for issue in caring_leave_metadata_issues:
        assert issue in response_warnings

    # patch with null values
    update_request_body = {
        "leave_details": {
            "caring_leave_metadata": {
                "family_member_first_name": None,
                "family_member_middle_name": None,
                "family_member_last_name": None,
                "family_member_date_of_birth": None,
                "relationship_to_caregiver": None,
            }
        }
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    response_warnings = response.get_json().get("warnings")

    assert response.status_code == 200
    for issue in caring_leave_metadata_issues:
        assert issue in response_warnings


def test_application_patch_caring_leave_metadata_change_leave_reason(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(
        user=user, phone=None, leave_reason_id=LeaveReason.CARE_FOR_A_FAMILY_MEMBER.leave_reason_id,
    )
    assert application.caring_leave_metadata is None

    application.caring_leave_metadata = CaringLeaveMetadataFactory.create()
    test_db_session.add(application)
    test_db_session.commit()

    # change leave reason to medical leave
    update_request_body = {
        "leave_details": {
            "reason": LeaveReason.SERIOUS_HEALTH_CONDITION_EMPLOYEE.leave_reason_description
        }
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    test_db_session.refresh(application)
    response_body = response.get_json()
    assert response.status_code == 200
    assert (
        application.leave_reason_id == LeaveReason.SERIOUS_HEALTH_CONDITION_EMPLOYEE.leave_reason_id
    )
    assert application.caring_leave_metadata is None
    assert response_body.get("data").get("leave_details").get("caring_leave_metadata") is None


def test_application_patch_caring_leave_metadata_family_member_date_of_birth_validation(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(
        user=user, phone=None, leave_reason_id=LeaveReason.CARE_FOR_A_FAMILY_MEMBER.leave_reason_id,
    )

    # use an invalid date of birth - more than 150 years in the past
    update_request_body = {
        "leave_details": {
            "caring_leave_metadata": {"family_member_date_of_birth": date(1849, 1, 1).isoformat()}
        }
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    assert response.status_code == 400

    response_body = response.get_json()
    errors = response_body.get("errors")
    assert len(errors) == 1

    error = errors[0]
    field = error.get("field")
    message = error.get("message")
    rule = error.get("rule")
    error_type = error.get("type")

    assert field == "leave_details.caring_leave_metadata.family_member_date_of_birth"
    assert message == "Date of birth must be within the past 150 years"
    assert rule == "date_of_birth_within_past_150_years"
    assert error_type == "invalid_year_range"


def test_application_patch_caring_leave_metadata_family_member_future_date_of_birth_validation(
    client, user, auth_token, test_db_session
):
    application = ApplicationFactory.create(
        user=user, phone=None, leave_reason_id=LeaveReason.CARE_FOR_A_FAMILY_MEMBER.leave_reason_id,
    )

    # use an invalid date of birth - more than 7 months in the future
    update_request_body = {
        "leave_details": {
            "caring_leave_metadata": {
                "family_member_date_of_birth": (
                    date.today() + relativedelta(months=7, days=1)
                ).isoformat()
            }
        }
    }

    response = client.patch(
        "/v1/applications/{}".format(application.application_id),
        headers={"Authorization": f"Bearer {auth_token}"},
        json=update_request_body,
    )

    assert response.status_code == 400

    response_body = response.get_json()
    errors = response_body.get("errors")
    assert len(errors) == 1

    error = errors[0]
    field = error.get("field")
    message = error.get("message")
    rule = error.get("rule")
    error_type = error.get("type")

    assert field == "leave_details.caring_leave_metadata.family_member_date_of_birth"
    assert message == "Family member's date of birth must be less than 7 months from now"
    assert rule == "max_7_months_in_future"
    assert error_type == "future_birth_date"
