# Contributing

## Delivery Workflow

Please see the [Delivery Workflow](https://lwd.atlassian.net/wiki/spaces/DD/pages/306577409/Delivery+Workflow)
Confluence page for guidance on how to pick up tickets, when to deploy, which environment to deploy to, etc.

## Local Development Guidelines

For practical instructions on getting set up locally, see the repo [README](../README.md).
Below are guidelines (not strict rules) for working once you're ready. Use your best judgement or consult your feel engineers to follow the spirit of the guidelines and know when it makes sense to deviate on a case by case basis.

We follow [trunk-based development](https://trunkbaseddevelopment.com/), which means:

- Make small changes in [short-lived feature branches](https://trunkbaseddevelopment.com/short-lived-feature-branches/) and merge to `main` frequently.
- Maintain a high test coverage in an automated test suite that runs on every pull request before merging.
- Utilize [feature flags](https://trunkbaseddevelopment.com/feature-flags/) to control the release of larger features.
- Keep each component (Portal, Admin Portal, and API) in a releasable state on its own.

### Keep system components separately releasable

- Treat the Claimant/Leave Admin Portal, the Admin Portal, and the API, as separate system components that are deployed separately. Components should always be releasable, in any order or at the same time. Avoid hard dependencies on changes to other components that are not already in production.
- Treat each change you merge to `main` as _immediately_ deployable to production. Do not merge changes that depend on subsequent changes you plan to make, even if you plan to make those changes shortly. Use feature flags or other techniques to make changes deployable (see section below on feature flags).
- Avoid changing more than one component in a single pull request, unless it's simpler and low risk to do so. In general, changes that depend on changes in other components should be planned ahead accordingly.

### Short-lived feature branches

- Prefix the branch name with your name e.g. `lorenyu/pfml-123-new-feature`.
- Be open to submitting [multiple small pull requests for a single ticket](https://trunkbaseddevelopment.com/short-lived-feature-branches/#pitfalls) (i.e. reference the same ticket across multiple PRs). Make sure each cumulative change is deployable on its own.
- Separate changes that include a lot of autogenerated diffs (e.g. new package dependencies or upgrades that create large diffs in poetry.lock and package-json.lock should be in their own PRs)
- Consider separating API design changes from implementation changes (e.g. adding new API endpoints to openapi.yaml can be in its own PR with stub implementations)

### Testing

- Add automated test coverage for new codeâ€‹. Keep tests passing. Update or remove tests if appropriate.
- Keep your branch updated with `main` regularly (at least daily):

    - Rebase your changes onto main with `git rebase main`, or

    - Merge main onto your own branch: `git merge main`.
  
    The favored pathway to keep your branch updated is to use `git merge main.`
    It's still possible to rebase and force-push your branch using `git rebase main`, but this pathway should be avoided
    if your branch is being worked on by more than one person at a time, due to the risk of causing unnecessary conflicts.

### Feature flags

- Utilize feature flags to have new logic live concurrently with old logic before the feature is complete end-to-end. See [Feature Flags](./portal/feature-flags.md)

### Code Reviews

- Get your code reviewed by your scrum team and in some cases additional component teams. See [code reviews](./code-reviews.md)
- Code reviewers are expected to review code quickly (within 1 business day)

### Merging

- Only merge **when all automated checks have returned green** and when the PR has received at least one approval.
  Although GitHub does not block the merge of a PR that fails its checks, any failed checks
  should be treated as a blocking issue and resolved before the PR is merged.
- **Verify that the commit title starts with the JIRA ticket.**
- Write clear, concise merge commit message titles. See [How to Write a Git Commit Message](https://chris.beams.io/posts/git-commit/#seven-rules)
- Clean up the merge commit message body to include a concise summary of the changes.

  **Use the PR description as a starting point. Do not use the default commit message from GitHub.**
  If the PR only has a single commit, GitHub will default to using that commit subject and description.
  This is often incorrect, missing the JIRA ticket.
  If the PR has multiple commits, GitHub will default to using the commit messages from each of the PR's commits.
  This is also often incorrect, as it is represents a history of the PR's changes rather than a concise summary of the changes.

  Do:

      PFML-540: Implement GET claims endpoint (#145)

      https://lwd.atlassian.net/browse/PFML-540

      Implements /claims endpoint which is a GET that takes a valid user ID and returns their first claim from the database.

      Demo: Unit tests and adhoc testing via swagger UI.
    
  Don't:

      add claims endpoint (#145)
    
      * formatting
    
      * fix
    
      * change endpoint
    
      * initial endpoint

### Note on Database Changes

A particular source of danger when merging a PR is the risk that the merge will introduce conflicts
to the PFML API's database schema. This scenario is not uncommon, especially for branches that
introduce new database migrations and that have not yet been updated with the latest changes to main.
The API's test suite cannot detect these conflicts, so they have historically been discovered
only after PR merge, when deployment of the API begins to fail.

To mitigate this risk, any engineer who introduces new database migrations to the API should pay special attention to the
"Pre-Merge Conflict Check", an automated check that should appear on any pull request that makes changes to `api/massgov/pfml/db/migrations/versions`.
This special 'pseudo-check' will diff your branch against main, and fail if it detects that your branch is missing any
database migrations that are already present on main.

To mitigate the risk that updates to main will, occasionally, introduce new database conflicts to unmerged branches,
this pseudo-check will automatically re-run itself whenever a new database migration is pushed to main,
and additionally whenever new commits are pushed to your PR's feature branch.

For these reasons, please make sure you check the status of any database conflicts before merging an approved PR.
To avoid these conflicts, any PR that alters the database _must_ be updated with the latest changes to main before being merged.
